[{"title":"Spring Cloud Eureka 服务发现","date":"2018-02-22T09:02:04.439Z","path":"2018/02/22/SpringCloud_01_Eureka/","text":"Spring Cloud是一套基于Spring Boot 实现的微服务开发工具，微服务(也称微服务架构)，简单地说，就是将一个系统按照一定的规则有效的拆分成多个不同的服务，每个服务都能独立的进行开发、管理、扩展、维护。服务与服务之间可以通过Restful API 等方式进行相互调用。 Spring Cloud并没有重复制造轮子，它只是将业界多个开源的微服务框架集成起来，再通过Spring Boot进行包装屏蔽复杂的配置和实现原理，目的就是给开发者一套简单易懂、易部署与维护的分布式系统开发工具包。它提供了微服务开发所需要的配置管理、服务发现、断路器、智能路由、微代理、控制总线等组件。 1、EurekaEureka是一种基于REST 的服务，主要用于定位服务，以实现中间层服务器的负载均衡和故障转移。它是由 Spring Cloud Netflix(Spring Cloud 子项目)项目提供的。 1.1、Spring Cloud Netflix它主要是对 Netflix 开源的一系列产品进行包装，为 Spring Boot 应用程序提供自动配置的 Netflix OSS 集成。通过一些简单的注解，就能快速启用并构建大型的分布式系统。它提供的模块有：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端负载均衡（Ribbon）。 1.2、样例项目结构 1.3、服务注册中心在 pom.xml 中声明使用spring-cloud-starter-eureka-server启动器（本示例对应的项目是eureka-server）12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 使用@EnableEurekaServer注解将应用声明为 Eureka 服务器端（Eureka Server），从而启动 Eureka 服务注册中心的组件，对外提供服务注册和发现的功能。123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 在默认的模式中，Eureka 服务器端也充当客户端并向给定的 serviceUrl 注册自己。在生产环境中，我们通常会有多台服务器端应用，但是为了简单起见，本示例使用单台服务器，因此需要禁掉 Eureka 服务器端应用的客户端行为： 1234567891011### 坐标： $&#123;hk-eureka-simple&#125;/src/main/resources/application.yml ###server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka 配置项 默认值 说明 eureka.instance.hostname - 实例的主机名 eureka.client.register-with-eureka true 该实例是否向 Eureka 服务器注册自己，以供外部应用发现自己。在某些情况下，你可能不希望当前的应用被外部的其他应用发现，而只是想从服务器发现其他服务的实例，此时你可以将此值设为 false eureka.client.fetch-registry true 该实例是否向 Eureka 服务器获取所有的注册信息表 eureka.client.service-url.defaultZone - 该实例与 Eureka 服务器通讯的 URL 地址列表。如果 Eureka 服务器地址不止一个，则使用英文的逗号分隔 Eureka 服务器默认监听 8761 端口来接收服务注册，除此之外它还提供一个可视化的直观页面，可以方便的查看注册的服务。EurekaServerApplication，访问：http://localhost:8761 从上图可以看到，此时还没有任何服务注册到 Eureka 服务器。 1.4、客户端（服务提供者）在 pom.xml 中声明使用spring-cloud-starter-eureka启动器（本示例对应的项目是user-service）： 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 使用@EnableEurekaClient或@EnableDiscoveryClient注解可以将应用声明为 Eureka 客户端（Eureka Client）。当客户端向 Eureka 服务器注册时，它会提供关于自身的一些元数据，例如主机和端口，健康指示符 URL，主页等信息。 123456789@SpringBootApplication@EnableEurekaClientpublic class UserServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceApplication.class, args); &#125;&#125; 还需要配置才能找到 Eureka 服务器：123456789101112### 坐标： $&#123;hk-user-service&#125;/src/main/resources/application.yml ###server: port: 8881spring: application: name: user-serviceeureka: client: service-url: defaultZone: http://localhost:8761/eureka spring.application.name是 Eureka 客户端向服务器注册的服务ID和虚拟主机的名称。在 Eureka 服务器中，服务ID相同的实例将集群在一起。UserServiceApplication，再次访问：http://localhost:8761 从上图可以看到，客户端应用程序已经成功被注册了。","tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://huankai.github.io/tags/Spring-Cloud/"}]},{"title":"Git 环境搭建","date":"2018-02-22T08:15:06.566Z","path":"2018/02/22/Git/","text":"安装环境：操作系统: CentOS Linux release 7.3.1611 (Core) 安装：1、Linux 做为服务器端系统，Windows 作为客户端系统，分别安装 Git服务器端：1[root@huangkai ~]# yum install -y git 安装完后，查看 Git 版本12[root@huangkai ~]# git --versiongit version 1.8.3.1 客户端：下载 Git for Windows，地址：https://git-for-windows.github.io ，或 点击这里 下载安装完之后，可以使用 Git Bash 作为命令行客户端。也可以使用 tortoiseGit 客户端来管理项目： 点击这里 下载查看 Git 版本：123huangkai@DESKTOP-MEKIV7C MINGW64 ~/Desktop$ git --versiongit version 2.14.2.windows.2 自报家门：这里要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录 123huangkai@DESKTOP-MEKIV7C MINGW64 ~/Desktop$ git config --global user.name \"huangkai\"$ git config --global user.email \"huankai@139.com\" 2、创建 git用户，用来管理 git 服务12345678[root@huangkai ~]# useradd git[root@huangkai ~]# passwd gitChanging password for user git.New password: BAD PASSWORD: The password is shorter than 8 charactersRetype new password: passwd: all authentication tokens updated successfully.[root@huangkai ~]# 3、创建 Git 仓库设置 /home/git/test.git 为 Git 裸仓库(一般以 .git结尾,裸仓库是没有工作区的，纯粹为了共享),然后把 Git 仓库的 拥有者 修改为 git用户1234567[root@huangkai ~]# cd /home/git/[root@huangkai git]# git --bare init test.gitInitialized empty Git repository in /home/git/test.git/[root@huangkai git]# chown -R git:git test.git[root@huangkai git]# lltotal 0drwxr-xr-x. 2 git git 6 Feb 12 22:10 test.git 4、客户端 clone 远程仓库 进入 Git Bash 命令行客户端，创建项目地址（设置在 d:/gittest）并进入此目录，然后从 Linux git 服务器上 clone 项目：12huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ git clone git@192.168.1.90:/home/git/test.git 如果SSH用的不是默认的22端口，则需要使用以下的命令（假设SSH端口号是7700）：12huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ git clone git@192.168.1.90:7700/home/git/test.git 当第一次连接到目标 Git 服务器时会得到一个提示：123The authenticity of host '192.168.1.90 (192.168.1.90)' can't be established.ECDSA key fingerprint is SHA256:HxWUbnmfhcxBEnkYtXPyN4xwA2OCNsE8WZzOsvhMaCY.Are you sure you want to continue connecting (yes/no)? 选择 yes：1Warning: Permanently added '192.168.1.90' (ECDSA) to the list of known hosts. 此时 C:/Users/用户名/.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句。后面提示要输入密码，可以采用 SSH 公钥来进行验证. 5、客户端创建 SSH 公钥和私钥123456789101112131415161718192021222324huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ ssh-keygen -t rsa -C \"huankai@139.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/huangkai/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/huangkai/.ssh/id_rsa.Your public key has been saved in /c/Users/huangkai/.ssh/id_rsa.pub.The key fingerprint is:SHA256:dXmadhishVapUGRtsrpr2QLpxLv04Yg7WQ22n6H85ww huankai@139.comThe key's randomart image is:+---[RSA 2048]----+| o+... || ...++. || .+=* . || o oo+ * || o =S.. = . || B + . . || *.=E* || oo=+B+o || ooo+==o |+----[SHA256]-----+huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest 输入回车、此时 C:/Users/用户名/.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub id_rsa 是私钥 id_rsa.pub 是公钥 6、服务器端 Git 打开 RSA 认证进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 保存并重启 sshd 服务：1[root@huangkai gittest]# systemctl restart sshd 由 AuthorizedKeysFile 得知公钥的存放路径是 .ssh/authorized_keys，实际上是 $Home/.ssh/authorized_keys，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 /home/git/.ssh/authorized_keys 在 /home/git/ 下创建目录 .ssh，将.ssh 文件夹的 owner 修改为 git1234567891011121314151617181920[root@huangkai git]# mkdir .ssh[root@huangkai git]# ls -latotal 12drwx------. 4 git git 89 Feb 12 22:29 .drwxr-xr-x. 4 root root 33 Feb 12 22:06 ..-rw-r--r--. 1 git git 18 Aug 3 2016 .bash_logout-rw-r--r--. 1 git git 193 Aug 3 2016 .bash_profile-rw-r--r--. 1 git git 231 Aug 3 2016 .bashrcdrwxr-xr-x. 3 git git 18 Feb 12 22:11 gittestdrwxr-xr-x. 2 root root 6 Feb 12 22:29 .ssh[root@huangkai git]# chown -R git:git .ssh[root@huangkai git]# ls -latotal 12drwx------. 4 git git 89 Feb 12 22:29 .drwxr-xr-x. 4 root root 33 Feb 12 22:06 ..-rw-r--r--. 1 git git 18 Aug 3 2016 .bash_logout-rw-r--r--. 1 git git 193 Aug 3 2016 .bash_profile-rw-r--r--. 1 git git 231 Aug 3 2016 .bashrcdrwxr-xr-x. 3 git git 18 Feb 12 22:11 gittestdrwxr-xr-x. 2 git git 6 Feb 12 22:29 .ssh 将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件 回到 Git Bash下，导入文件,输入服务器端 git 用户的密码（就是git用户的密码） 123456huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ ssh git@192.168.1.90 'cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pubgit@192.168.1.90's password:huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ 回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件：123456[root@huangkai .ssh]# ls -latotal 4drwxr-xr-x. 2 git git 29 Feb 12 22:43 .drwx------. 4 git git 89 Feb 12 22:39 ..-rw-rw-r--. 1 git git 397 Feb 12 22:43 authorized_keys[root@huangkai .ssh]# 可以通过 cat 查看authorized_keys 的内容 重要：修改 .ssh 目录的权限为 700 修改 .ssh/authorized_keys 文件的权限为 600 123456[root@huangkai git]# chmod 700 .ssh/[root@huangkai git]# cd .ssh/[root@huangkai .ssh]# lltotal 4-rw-rw-r--. 1 git git 397 Feb 12 22:43 authorized_keys[root@huangkai .ssh]# chmod 600 authorized_keys 客户端再次 clone :12huangkai@DESKTOP-MEKIV7C MINGW64 /d/gittest$ git clone git@192.168.1.90:/home/git/gittest/.git 7、禁止 git 用户 ssh 登录服务器之前在服务器端创建的 git 用户将此用户不允许 ssh 登录服务器 编辑 /etc/passwd 找到：1git:x:1001:1001::/home/git:/bin/bash 修改为1git:x:1001:1001::/home/git:/bin/git-shell 此时 git 用户可以正常通过 ssh 使用 git，但无法通过 ssh 登录系统。 参考资料： https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000https://git-scm.com/docs","tags":[{"name":"Git","slug":"Git","permalink":"https://huankai.github.io/tags/Git/"}]},{"title":"Thymeleaf 教程","date":"2018-02-22T07:15:02.821Z","path":"2018/02/22/Thymeleaf_01/","text":"Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择。 1. 创建模板文件创建一个 HTML 模板文件： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 通过引入 Thymeleaf 命名空间。th:text用于处理p标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性th:text。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用th:*这些非标准属性的。我们可以切换到 Thymeleaf 的data-th-*语法，以此来替换th:*语法： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-th-text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML5 规范是允许data-*这样自定义的属性的。th:*和data-th-*这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用th:*的表示形式。 2. 标准表达式语法Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类： 简单表达式 字面值 文本操作 算术运算 布尔运算 比较和相等 条件运算 无操作符 2.1 简单表达式 语法 名称 描述 作用 ${…} Variable Expressions 变量表达式 取出上下文变量的值 *{…} Selection Variable Expressions 选择变量表达式 取出选择的对象的属性值 #{…} Message Expressions 消息表达式 使文字消息国际化，I18N @{…} Link URL Expressions 链接表达式 用于表示各种超链接地址 ~{…} Fragment Expressions 片段表达式 引用一段公共的代码片段 2.1.1 ${…}1234567@GetMapping(\"/standard-expression-syntax/variables\")public String variables(ModelMap model, HttpSession session) &#123; model.put(\"now\", new Date()); model.put(\"message\", \"Welcome to BeiJing!\"); session.setAttribute(\"user\", new User(\"test\", \"男\", 24)); ... ...&#125; 通过变量表达式${}取出上下文环境中的message变量：12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 它相当于：1ctx.getVariable(\"message\"); 2.1.2 *{…}变量表达式${}是面向整个上下文的，而选择变量表达式*{}的上下文是父标签（th:object）所选择的对象：12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p th:text=\"*&#123;name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 它相当于：12345&lt;div&gt; &lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 如果对象没有被选择，那么，*{}和${}表达式所达到的效果是完全相同的：12&lt;p th:text=\"*&#123;session.user.name&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.3 #{…}消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则： basename.properties basename_language.properties basename_language_country.properties basename 是自定义的资源文件名称，language和country必须是 Java 支持的语言和国家。basename.properties是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。 创建文件 src/main/resources/messages.properties，内容如下：1welcome.message = 北京欢迎你！ 创建文件src/main/resources/messages_en_US.properties，内容如下：1welcome.message = Welcome to BeiJing! messages是 Spring Boot 加载资源文件默认采用的名称（basename），如果你所使用的资源文件名称不是以messages命名或所使用的资源文件不是在src/main/resources根目录，你可以通过spring.messages.basename属性来做具体的配置。如，资源文件messages.properties和messages_en_US.properties假设它们所在的目录位置是src/main/resources/i18n。 application.properties 配置示例：1spring.messages.basename:i18n/messages application.yml 配置示例：123spring messages basename: i18n/messages 静态文本消息示例：12&lt;!-- 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcom.message&#125;\"&gt;&lt;/p&gt; 消息表达式#{}是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符{}来处理非静态的文本消息：messages.properties 配置示例： 1welcome.user.message = &#123;0&#125;, 北京欢迎你！ messages_en_US.properties 配置示例：1welcome.user.message = &#123;0&#125;, Welcome to BeiJing! 非静态文本消息，以参数的形式传递变量的值：12&lt;!-- test, 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcome.user.message($&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.4 @{…}链接表达式@{}是专门用来处理 URL 链接地址的。绝对地址示例：12&lt;!-- https://huankai.github.io --&gt;&lt;p th:text=\"@&#123;https://huankai.github.io&#125;\"&gt;&lt;/p&gt; 页面相对地址示例：12&lt;!-- commons/base.html --&gt;&lt;p th:text=\"@&#123;commons/base.html&#125;\"&gt;&lt;/p&gt; 上下文相对地址（相对于当前的服务）示例：12&lt;!-- /css/mian.css --&gt;&lt;p th:text=\"@&#123;/css/mian.css&#125;\"&gt;&lt;/p&gt; 服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：12&lt;!-- /image/upload --&gt;&lt;p th:text=\"@&#123;~/image/upload&#125;\"&gt;&lt;/p&gt; 参数使用示例：12345678&lt;!-- /css/mian.css?v=1.0 --&gt;&lt;p th:text=\"@&#123;/css/mian.css(v=1.0)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie&amp;status=PAIED --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;,status='PAIED')&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/fanlychie/info --&gt;&lt;p th:text=\"@&#123;/user/&#123;username&#125;/info(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.5 ~{…}片段表达式~{}可以用来引用一段公共的 HTML 代码片段。 语法 描述 ~{templatename} 引用整个模板文件的代码片段 ~{templatename :: selector} selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等 ~{::selector} 相当于 ~{this :: selector}，表示引用当前模板定义的代码片段 在 Thymeleaf 模板文件中，你可以使用th:fragment属性来定义一段公共的代码片段，然后你可以通过使用th:insert、th:replace、th:include（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。src/main/resources/templates/base.html，通过th:fragment属性定义一段公共的代码片段： 1&lt;div id=\"footer\" th:fragment=\"footerFragment\"&gt;&amp;copy; 2017 huangkai&lt;/div&gt; src/main/resources/templates/index.html，通过th:insert属性引用一段公共的代码片段：1&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 其中，~{}是可选的，我们可以去掉这层的包裹：1&lt;div th:insert=\"base :: footerFragment\"&gt;&lt;/div&gt; 若 index.html 与 base.html 不在同级目录，如 templates/commons/base.html：1&lt;div th:insert=\"~&#123;commons/base :: footerFragment&#125;\"&gt;&lt;/div&gt; 使用th:fragment属性定义代码片段时，你还可以声明一组参数：123456789&lt;div th:fragment=\"crumbs(parent, child)\"&gt; &lt;i th:text=\"$&#123;parent&#125;\"&gt;&lt;/i&gt; &lt;i th:text=\"$&#123;child&#125;\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;!--&lt;i&gt;用户中心&lt;/i&gt;&lt;i&gt;我的订单&lt;/i&gt;--&gt;&lt;div th:insert=\"::crumbs('用户中心', '我的订单')\"&gt;&lt;/div&gt; 此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：1&lt;div th:insert=\"~&#123;base :: #footer&#125;\"&gt;&lt;/div&gt; 除了th:insert属性th:replace也可以用来引用公共的代码片段。不同的是，th:insert是直接将代码片段插入到标签体内，而th:replace则是用代码片段直接替换标签体内容。1234567891011&lt;!--&lt;div&gt; &lt;div id=\"footer\"&gt;© 2017 huangkai&lt;/div&gt;&lt;/div&gt;--&gt;&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; &lt;!--&lt;div id=\"footer\"&gt;© 2017 huangkai&lt;/div&gt;--&gt;&lt;div th:replace=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 2.1.6 内置对象 对象 描述 #ctx 上下文对象 #vars 同 #ctx，表示上下文变量 #locale 上下文本地化（特定的地理区域）变量，可参考 java.util.Locale #request HttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest #response HttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse #session HttpSession 对象，可参考 javax.servlet.http.HttpSession #servletContext ServletContext 对象，可参考 javax.servlet.ServletContext #ctx示例：123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#ctx.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#ctx.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#ctx.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #vars示例：123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#vars.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#vars.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#vars.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #locale示例：123456789101112&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#locale&#125;\"&gt;&lt;/p&gt;&lt;!-- CN --&gt;&lt;p th:text=\"$&#123;#locale.country&#125;\"&gt;&lt;/p&gt;&lt;!-- 中国 --&gt;&lt;p th:text=\"$&#123;#locale.displayCountry&#125;\"&gt;&lt;/p&gt;&lt;!-- zh --&gt;&lt;p th:text=\"$&#123;#locale.language&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 --&gt;&lt;p th:text=\"$&#123;#locale.displayLanguage&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 (中国) --&gt;&lt;p th:text=\"$&#123;#locale.displayName&#125;\"&gt;&lt;/p&gt; #request示例：12345678910111213141516171819202122&lt;!-- HTTP/1.1 --&gt;&lt;p th:text=\"$&#123;#request.protocol&#125;\"&gt;&lt;/p&gt;&lt;!-- http --&gt;&lt;p th:text=\"$&#123;#request.scheme&#125;\"&gt;&lt;/p&gt;&lt;!-- localhost --&gt;&lt;p th:text=\"$&#123;#request.serverName&#125;\"&gt;&lt;/p&gt;&lt;!-- 8080 --&gt;&lt;p th:text=\"$&#123;#request.serverPort&#125;\"&gt;&lt;/p&gt;&lt;!-- GET --&gt;&lt;p th:text=\"$&#123;#request.method&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURI&#125;\"&gt;&lt;/p&gt;&lt;!-- http://localhost:8080/standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURL&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.servletPath&#125;\"&gt;&lt;/p&gt;&lt;!-- java.util.Collections$3@203646fe --&gt;&lt;p th:text=\"$&#123;#request.parameterNames&#125;\"&gt;&lt;/p&gt;&lt;!-- &#123;q=[Ljava.lang.String;@3308c69f&#125; --&gt;&lt;p th:text=\"$&#123;#request.parameterMap&#125;\"&gt;&lt;/p&gt;&lt;!-- q=expression --&gt;&lt;p th:text=\"$&#123;#request.queryString&#125;\"&gt;&lt;/p&gt; 注意，请求地址的 URL 参数直接通过#request.x是取不出来的，需要使用param.x语法来取出。如，URL：/standard-expression-syntax/variables?q=expression，取出 q 参数的正确姿势：1&lt;p th:text=\"$&#123;param.q&#125;\"&gt;&lt;/p #response示例：12345678&lt;!-- 200 --&gt;&lt;p th:text=\"$&#123;#response.status&#125;\"&gt;&lt;/p&gt;&lt;!-- 8192 --&gt;&lt;p th:text=\"$&#123;#response.bufferSize&#125;\"&gt;&lt;/p&gt;&lt;!-- UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.characterEncoding&#125;\"&gt;&lt;/p&gt;&lt;!-- text/html;charset=UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.contentType&#125;\"&gt;&lt;/p&gt; #session示例：123456&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;&lt;p th:text=\"$&#123;#session.id&#125;\"&gt;&lt;/p&gt;&lt;!-- 1499786693244 --&gt;&lt;p th:text=\"$&#123;#session.lastAccessedTime&#125;\"&gt;&lt;/p&gt;&lt;!-- huangkai --&gt;&lt;p th:text=\"$&#123;#session.getAttribute('user').name&#125;\"&gt;&lt;/p&gt; 注意，放到会话里面的对象直接通过#session.x是取不出来的，需要使用session.x语法来取出。如，取出会话里面的 user 对象的正确姿势：1&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.7 工具类 对象 描述 #messages 消息工具类，与 ＃{…} 作用相同 #uris 地址相关的工具类 #conversions 对象转换工具类 #dates 日期时间工具类 #calendars 日历工具类 #numbers 数字工具类 #strings 字符串工具类 #objects 对象工具类 #bools 布尔工具类 #arrays 数组工具类 #lists List 工具类 #sets Set 工具类 #maps Map 工具类 1234&lt;!-- false --&gt;&lt;p th:text=\"$&#123;#strings.isEmpty(message)&#125;\"&gt;&lt;/p&gt;&lt;!-- 2017-07-27 14:37:25 --&gt;&lt;p th:text=\"$&#123;#dates.format(now, 'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;&lt;/p&gt; 2.2 字面值所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：18、’welcome’等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。 2.2.1 文字字面值文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：1234&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt;&lt;!-- 'Welcome to BeiJing!' --&gt;&lt;p th:text=\"'\\'Welcome to BeiJing!\\''\"&gt;&lt;/p&gt; 2.2.2 数字字面值1234&lt;!-- 2017 --&gt;&lt;p th:text=\"2017\"&gt;&lt;/p&gt;&lt;!-- 2018 --&gt;&lt;p th:text=\"2017 + 1\"&gt;&lt;/p&gt; 2.2.3 布尔字面值1234&lt;!-- false --&gt;&lt;p th:text=\"1 &gt; 2\"&gt;&lt;/p&gt;&lt;!-- 否 --&gt;&lt;p th:text=\"1 &gt; 2 ? '是' : '否'\"&gt;&lt;/p&gt; 2.2.4 空字面值12&lt;!-- false --&gt;&lt;p th:text=\"$&#123;user == null&#125;\"&gt;&lt;/p&gt; 2.2.5 字面令牌字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）： 大写或小写的字母、中文等不含空格和特殊符号的文本 0 到 9 的数字 中括号 下划线 连字符（-） 点符号（.） 实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：123&lt;p th:text=\"Welcome to BeiJing!\"&gt;&lt;/p&gt;它等效于：&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt; 2.3 文本操作我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。 2.3.1 字符串连接不管是字面值还是表达式的结果，我们都可以使用+符号将它们连接起来：12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to ' + $&#123;location&#125; + '!'\"&gt;&lt;/p&gt; 2.3.2 字面值替换符号||可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用+连接符：12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"|Welcome to $&#123;location&#125;!|\"&gt;&lt;/p&gt; 2.4 算术运算支持+（加）、-（减）、*（乘）、/（除）、%（模）运算：1234567891011121314&lt;!-- 6 --&gt;&lt;p th:text=\"4 + 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 - 2\"&gt;&lt;/p&gt;&lt;!-- 8 --&gt;&lt;p th:text=\"4 * 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 / 2\"&gt;&lt;/p&gt;&lt;!-- 0 --&gt;&lt;p th:text=\"4 % 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page + 1&#125;\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page&#125; + 1\"&gt;&lt;/p&gt; 2.5 布尔运算支持and（且）、or（或）、!（非）、not（非）运算：1234&lt;p th:text=\"$&#123;user.online and user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online or user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;!user.online&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;not user.online&#125;\"&gt;&lt;/p&gt; 2.6 比较和相等支持&lt;（lt）、&gt;（gt）、&lt;=（le）、&gt;=（ge）、==（eq）、！=（ne）：123456&lt;p th:text=\"$&#123;user.age &lt; 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &lt;= 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt; 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt;= 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age == 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age != 18&#125;\"&gt;&lt;/p&gt; 2.7 条件运算三元运算符：(if) ? (then) : (else)12&lt;p th:text=\"$&#123;user.online ? '在线' : '离线'&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online ? (user.vip ? 'VIP用户在线' : '普通用户在线') : '离线'&#125;\"&gt;&lt;/p&gt; 二元运算符：(value) ?: (defaultValue)。其中，value非空（null）即真，条件为真时输出value，否则输出defaultValue。假设token = null，user.email = huankai@139.com1234&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: '你还没有登录，请先登录'\"&gt;&lt;/p&gt;&lt;!-- huankai@139.com --&gt;&lt;p th:text=\"$&#123;user.email&#125; ?: '你还没有绑定邮箱'\"&gt;&lt;/p&gt; 2.8 无操作符当模板运行在服务器端时，Thymeleaf 会解析th:*属性的具体值替换标签体的内容。无操作符（_）则允许你使用原型标签体的内容作为默认值：12&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: _\"&gt;你还没有登录，请先登录&lt;/p&gt; 3. 使用文本首先介绍两个最基础的th:*属th:text和th:utext，它们都是用于处理文本消息内容 3.1 th:text标签体中展示表达式评估结果的文本内容：1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 使用外部化的文本内容：1&lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt; 当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的th:text属性，而显示 p 标签体的文本内容Welcome to BeiJing!当它作为模板文件运行在服务器端时，th:text属性的具体值将会替换 p 标签体的文本内容。 3.2 th:utext属性th:utext与th:text的区别在于： th:text默认会对含有 HTML 标签的内容进行字符转义； th:utext（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义； 假设：message = “Welcome to BeiJing!“。使用th:text属性：1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:text效果：&lt;b&gt;Welcome to BeiJing!&lt;/b&gt; 使用th:utext属性：1&lt;p th:utext=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:utext效果：Welcome to BeiJing! 4. 设置属性值在 Thymeleaf 模板文件中，你可以使用th:*（或者使用th:attr属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以th:*-*来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用th:attrappend和th:attrprepend来追加新的值到现有的标签属性值中。 4.1 th:attr这种方式是不被推荐的，了解一下就行。下面是用th:attr=”href=…”来设置标签href属性的值：1&lt;a th:attr=\"href=@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 4.2 th:*显然th:attr=”href=@{http://www.baidu.com}”不够简洁，我们更推荐下面的这种语法：1&lt;a th:href=\"@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 其中th:*中的 * 可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：12&lt;!-- &lt;div item-id=\"1001\"&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;&lt;div th:item-id=\"$&#123;user.id&#125;\"&gt;Welcome to BeiJing!&lt;/div&gt; 4.3 th:*-*如果想要同时为标签的多个不同属性设置相同的一个值，可以使用th:*-*的语法：1&lt;img src=\"logo.png\" th:alt-title=\"LOGO图片\"&gt; 它相当于：1&lt;img src=\"logo.png\" th:alt=\"LOGO图片\" th:title=\"LOGO图片\"&gt; 4.4 th:attrappend &amp; th:attrprependth:attrappend和th:attrprepend可以将表达式的结果分别追加到指定的属性值之后和之前。1234&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrappend=\"class=$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt;&lt;!-- &lt;button class=\"enable btn\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrprepend=\"class=$&#123;outOfStock&#125; ? 'enable ' : 'disable '\"&gt;购买&lt;/button&gt; 另外，还有两个常用的具体附加属性th:classappend=”…”和th:styleappend=””。它们分别用来代替th:attrappend=”class=…”和th:attrappend=”style=…”。 12&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:classappend=\"$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt; 4.5 布尔属性在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如readonly、checked、selected等。它们若存在那就意味着值为 true。12345678910&lt;input type=\"checkbox\" name=\"rememberme\" checked /&gt; 记住我&lt;input type=\"radio\" name=\"sex\" value=\"male\" checked&gt; 男&lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt; 女&lt;input type=\"text\" name=\"appId\" value=\"J123654\" readonly&gt;&lt;select&gt; &lt;option selected&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt;&lt;/select&gt; Thymeleaf 也允许我们通过th:*（这里的*表示任意的布尔属性） 来选择是否使用这些布尔属性。1&lt;input type=\"checkbox\" name=\"rememberme\" ch:checked=\"$&#123;rememberme&#125;\" /&gt; 记住我 正如你所见，如果表达式的结果为true，则自动勾选复选框，若为false，则不会自动勾选。 5. 遍历遍历（迭代）的语法th:each=”自定义的元素变量名称 : ${集合变量名称}”： 123456&lt;div&gt; &lt;spn&gt;你所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 属性th:each提供了一个用于跟踪迭代的状态变量，它包含以下几个属性： 属性 类型 描述 index int 当前迭代的索引，从 0 开始 count int 当前迭代的计数，从 1 开始 size int 集合中元素的总个数 current int 当前的元素对象 even boolean 当前迭代的计数是否是偶数 odd boolean 当前迭代的计数是否是奇数 first boolean 当前元素是否是集合的第一个元素 last boolean 当前元素是否是集合的最后一个元素 状态变量的使用语法：th:each=”自定义的元素变量名称, 自定义的状态变量名称 : ${集合变量名称}”：123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city, status : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;status.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 不管什么时候，Thymeleaf 始终会为每个th:each创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加Stat字符串组成：123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;cityStat.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 6. 条件判断条件判断语句有三种，分别是：th:if、th:unless、th:swith。 6.1 th:if当表达式的评估结果为真时则显示内容，否则不显示： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user != null&#125;\"&gt;我的订单&lt;/a&gt; 真假评估的依据： 当表达式的值不为空（null）时 如果表达式的值是一个布尔类型，且值为true评估为真，否则为假 如果表达式的值是一个数字类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符串类型，且值为非”false”、”off”、”no”评估为真，否则为假 如果表达式的值不是一个布尔、数字、字符或字符串评估为真 当表达式的值为空（null）时，评估结果为假 因此，上面代码我们也可以简写成：1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user&#125;\"&gt;我的订单&lt;/a&gt; 但是，为了代码的可读性，我们并不建议这样使用。 6.2 th:unlessth:unless与th:if判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:unless=\"$&#123;user == null&#125;\"&gt;我的订单&lt;/a&gt; 6.3 th:swith多路选择语句，它需要搭配th:case来使用： 1234&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt; 7. 定义局部变量使用th:with属性可以定义局部变量：123&lt;p th:with=\"name='fanlychie'\"&gt; &lt;span th:text=\"$&#123;name&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; 同时定义多个局部变量时，用英文,号分隔开： 123&lt;p th:with=\"name=$&#123;user.name&#125;,age=&#123;user.age&#125;\"&gt; ......&lt;/p&gt; 8. 注释下面介绍常见的两种注释： 8.1 标准注释语法：&lt;!-- ... ---&gt;，注释的代码块会在文件源代码中显示出来。 8.1.1 单行注释1&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt; 8.1.2 多行注释123456&lt;!--&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;---&gt; 8.2 解析器级注释语法：&lt;!--/* ... */--&gt;，注释的代码块会在引擎解析的时候抹去。 8.2.1 单行注释：1&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt; 8.2.2 多行注释123456&lt;!--/*--&gt;&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;&lt;!--*/--&gt; 9. 内联表达式内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用th:*标签属性。 9.1 [[…]][[]]相当于th:text，对含有 HTML 标签的内容自动进行字符转义。1&lt;p&gt;The message is : [[$&#123;htmlContent&#125;]]&lt;/p&gt; 9.2 [(…)][()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义。1&lt;p&gt;The message is : [($&#123;htmlContent&#125;)]&lt;/p&gt; 9.3 th:inline我们已经了解到，使用[[]]和[()]语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用th:inline属性来激活，它的取值如下： 值 描述 none 禁止内联表达式，可以原样输出 [[]] 和 [()] 字符串 text 文本内联，可以使用 th:each 等高级语法 css 样式内联，如：&lt;style th:inline=&quot;css&quot;&gt; javascript 脚本内联，如：&lt;style th:inline=&quot;javascript&quot;&gt; 9.3.1 none12&lt;!-- [[1, 2], [3, 4]] --&gt;&lt;p th:inline=\"none\"&gt;[[1, 2], [3, 4]]&lt;/p&gt; 9.3.2 text123456&lt;!-- 北京 上海 广州 深圳 --&gt;&lt;p th:inline=\"text\"&gt; [# th:each=\"city : $&#123;cities&#125;\"] [($&#123;city.name&#125;)] [/]&lt;/p&gt; 9.3.3 css12345&lt;style th:inline=\"css\"&gt; body &#123; background-color:[[$&#123;bgColor&#125;]]; &#125;&lt;/style&gt; 9.3.4 javascript1234&lt;script th:inline=\"javascript\"&gt; var user = [[$&#123;user&#125;]]; alert(\"用户名：\" + user.name);&lt;/script&gt; 参考文档文献链接 : http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html","tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://huankai.github.io/tags/Thymeleaf/"}]},{"title":"Linux Svn 服务器搭建","date":"2018-02-22T07:15:02.811Z","path":"2018/02/22/Svn服务器搭建/","text":"1. 检查svn版本是否有安装1rpm -qa subversion 执行上面的命令，没有任何显示，表示没有安装，如果有，执行 yum remove subversion 删除。 2. 执行安装1yum -y install subversion 等待安装完成即可 3. 配置和启动svn服务器 创建目录 ： 12mkdir -p /data/svn/data # svn数据保存目录 -p 参数表示如果子目录不存在，也会级联创建目录mkdir -p /data/svn/passwd #svn公共用户密码与权限目录 启动 svn服务： 123svnserve -d -r /data/svn/data/-d 守护进程启动 -r 指定svn目录 查看服务进程： 123ps -ef|grep svnroot 1748 1 0 21:44 ? 00:00:00 svnserve -d -r /data/svn/data/root 1771 1401 0 21:45 pts/0 00:00:00 grep --color=auto svn 如上，表示svn服务已启动 查看端口号：&nbsp;&nbsp;svn默认使用的端口号为 3690123lsof -i:3690COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsvnserve 1748 root 3u IPv4 24804 0t0 TCP *:svn (LISTEN) 或者使用如下方式查看12netstat -lntup|grep 3690tcp 0 0 0.0.0.0:3690 0.0.0.0:* LISTEN 1748/svnserve 4. 创建svn仓库123456789101112131415161718[root@huangkai200 data]# svnadmin create hk #创建仓库， hk 是仓库名称[root@huangkai200 data]# lshk[root@huangkai200 data]# cd hk/[root@huangkai200 hk]# ll # 查看仓库目录结构total 16drwxr-xr-x 2 root root 51 Mar 12 21:58 conf # svn仓库配置文件 drwxr-sr-x 6 root root 4096 Mar 12 21:58 db #数据存放文件-r--r--r-- 1 root root 2 Mar 12 21:58 format drwxr-xr-x 2 root root 4096 Mar 12 21:58 hooksdrwxr-xr-x 2 root root 39 Mar 12 21:58 locks-rw-r--r-- 1 root root 229 Mar 12 21:58 README.txt[root@huangkai200 hk]# cd conf/ [root@huangkai200 conf]# ll total 12-rw-r--r-- 1 root root 1080 Mar 12 21:58 authz #权限管理文件 -rw-r--r-- 1 root root 309 Mar 12 21:58 passwd #用户与密码文件 -rw-r--r-- 1 root root 3090 Mar 12 21:58 svnserve.conf #主配置文件，包含上面authz 与 passwd文件 5、修改 svnserver.conf 主配置文件123456789101112131415161718192021222324252627282930313233343536373839404142[root@huangkai200 conf]# vi svnserve.conf### This file controls the configuration of the svnserve daemon, if you### use it to allow access to this repository. (If you only allow### access through http: and/or file: URLs, then this file is### irrelevant.)### Visit http://subversion.apache.org/ for more information. [general]### The anon-access and auth-access options control access to the### repository for unauthenticated (a.k.a. anonymous) users and### authenticated users, respectively.### Valid values are \"write\", \"read\", and \"none\".### Setting the value to \"none\" prohibits both reading and writing;### \"read\" allows read-only access, and \"write\" allows complete### read/write access to the repository.### The sample settings below are the defaults and specify that anonymous### users have read-only access to the repository, while authenticated### users have read and write access to the repository.# anon-access = read #将此项目默认配置改为 none，svn默认对未认证的用户有只读权限，我们要将此用户的权限设置为 none，然后将 20行 的 auth-access 的注解删除anon-access = none auth-access = write### The password-db option controls the location of the password### database file. Unless you specify a path starting with a /,### the file's location is relative to the directory containing### this configuration file.### If SASL is enabled (see below), this file will NOT be used.### Uncomment the line below to use the default password file.# svn默认每个仓库会指定密码文件 ，为了多个仓库统一密码管理 ，将此选项设置为公共的密码文件password-db = /data/svn/passwd/passwd### The authz-db option controls the location of the authorization### rules for path-based access control. Unless you specify a path### starting with a /, the file's location is relative to the the### directory containing this file. If you don't specify an### authz-db, no path-based access control is done.### Uncomment the line below to use the default authorization file.authz-db = /data/svn/passwd/authz #和密码一样，将此选项设置为公共的权限文件### This option specifies the authentication realm of the repository.### If two repositories have the same authentication realm, they should### have the same password database, and vice versa. The default realm### is repository's uuid.# realm = My First Repository 6、拷贝authz 和 passwd 文件 到 公共用户与密码的目录1234567891011121314[root@huangkai200 hk]# cp authz passwd /data/svn/passwd[root@huangkai200 passwd]# ll # 可以看到，如下两个文件的权限为 644（文件所有者可读可写，所在组可读，其它组可读，这样，其它用户就可以看到这两个文件 ，文件的安全性就降低了）total 8-rw-r--r-- 1 root root 1080 Mar 12 22:27 authz-rw-r--r-- 1 root root 329 Mar 12 22:25 passwd[root@huangkai200 passwd]# 修改文件权限：[root@huangkai200 passwd]# chmod 600 * #(给文件所有者可读写权限，其它用户没有权限)[root@huangkai200 passwd]# lltotal 8-rw------- 1 root root 1080 Mar 12 22:27 authz-rw------- 1 root root 329 Mar 12 22:25 passwd 7、SVN添加账户在 passwd文件中[users]下按例子添加账户12345678910[root@huangkai200 passwd]# vi passwd### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry = harryssecret# sally = sallyssecrethuangkai = huangkai #添加账号，等号前为用户名，等号后为 密码 8、修改authz配置文件123456789101112131415161718192021222324252627282930313233343536373839[root@huangkai200 passwd]# vi authz### This file is an example authorization file for svnserve.### Its format is identical to that of mod_authz_svn authorization### files.### As shown below each section defines authorizations for the path and### (optional) repository specified by the section name.### The authorizations follow. An authorization line can refer to:### - a single user,### - a group of users defined in a special [groups] section,### - an alias defined in a special [aliases] section,### - all authenticated users, using the '$authenticated' token,### - only anonymous users, using the '$anonymous' token,### - anyone, using the '*' wildcard.###### A match can be inverted by prefixing the rule with '~'. Rules can### grant read ('r') access, read-write ('rw') access, or no access### ('').[aliases]# joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average[groups]# harry_and_sally = harry,sally# harry_sally_and_joe = harry,sally,&amp;joe# [/foo/bar]# harry = rw# &amp;joe = r# * =# [repository:/baz/fuz]# @harry_and_sally = rw# * = r[hk:/]huangkai = rw#权限配置规则#[版本库:/项目/目录]#用户名 = rw(可写可读) | r (只读)#也可以指定组，一个组对应一个或多个用户多个用户用 逗号隔开# gruop_1 = huangkai,...#为组配置权限规则,如 ： @ 组名# @gruop_1 = rw 修改 authz 与 passwd文件 不需要重启svn服务器，但修改 svnserver.conf 必须重启使配置生效，authz 与 passwd 配置文件不能写错，否则服务可能不能正常启动。 启动服务: 12345678910[root@huangkai200 passwd]# lsof -i:3690 #先查看服务是否启动COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsvnserve 1748 root 3u IPv4 24804 0t0 TCP *:svn (LISTEN)root@huangkai200 passwd]# kill -9 1748 #如果有启动，先关闭[root@huangkai200 passwd]# ps -ef|grep svnroot 3252 1401 0 22:58 pts/0 00:00:00 grep --color=auto svn[root@huangkai200 passwd]# svnserve -d -r /data/svn/data/ #启动服务 9、svn 开机启动首先：编写一个启动脚本svn_startup.sh，我放在/data/svn/svn_startup.sh12#!/bin/bash/usr/bin/svnserve -d -r /data/svn/data/ 这里的svnserve路径保险起见，最好写绝对路径，因为启动的时候，环境变量也许没加载。绝对路径怎么查？使用 which svnserve 查看：12[root@huangkai200 hk]# which svnserve /usr/bin/svnserve 然后修改该脚本的执行权限：1[root@huangkai200 svn]# chmod 700 svn_startup.sh 最后：加入自动运行12[root@huangkai200 svn]#vi /etc/rc.d/rc.local在末尾添加脚本的路径，如：/data/svn/svn_startup.sh 看看 /etc/rc.d/rc.local的权限，如果没有可执行权限，则需要设置 ， chmod 711 /etc/rc.d/rc.local 10、svn 客户端连接 ：确保防火墙关闭或开放 3690 端口，现在，你可以重启一下试试了1svn://ip地址:3690/hk","tags":[{"name":"Linux","slug":"Linux","permalink":"https://huankai.github.io/tags/Linux/"},{"name":"Svn","slug":"Svn","permalink":"https://huankai.github.io/tags/Svn/"}]},{"title":"Spring Boot 快速入门 - 1 分钟搭建 Web 应用","date":"2018-02-22T07:15:02.803Z","path":"2018/02/22/Spring_Boot_01/","text":"Spring Boot 不是一个新的框架，它是提供一种使我们更易于创建基于 Spring 的最小或零配置的独立应用和服务的方式。 Spring 对于 Java 开发者来说一定都并不陌生，它作为目前非常流行的一个 Java 应用开发的基础框架，应用非常广泛。然而，由于其配置繁杂，各样格式的XML配置文件，着实让人头疼。 Spring Boot 的出现，可以让我们只需要非常简单的几步就可以搭建起一个基于 Spring 框架的 Web 应用程序。Spring Boot的主要目标： 为所有的Spring开发提供一个更快，更广泛的入门体验; 开箱即用，以最小或零配置的方式，使我们更专注于解决应用程序的功能需求; 提供一些非功能性的常见的大型项目类特性（如内嵌服务器、安全、度量、健康检查、外部化配置）; 绝对没有代码生成，也不需要XML配置，可以完全避免XML配置; 为了避免定义更多的注释配置（它将一些现有的 Spring 框架注释组合成一个简单的单个注释）; 提供一些默认值，以便在任何时间内快速启动新项目。 1. 项目依赖1234567891011121314151617181920212223242526272829&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hk&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-quick-start&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-quick-start&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2. 控制器12345678@RestControllerpublic class HelloWorldController &#123; @GetMapping(\"/\") public String sayHello() &#123; return \"Hello, Spring Boot!\"; &#125;&#125; 3. 主应用程序类Spring Boot 建议我们将主应用程序类置于其他类之上的根包名之下。这样就相当于隐式的的定义了注解扫描的基础搜索包名，而不需要指定 scanBasePackages 属性。12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 4. 运行直接运行 Application 中的 main 方法：123456789101112131415161718192021222324252627282930 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.7.RELEASE)2017-10-12 13:02:06.791 INFO 7188 --- [ main] com.hk.Application : Starting Application on FANLYCHIE-PC with PID 7188 (F:\\dev\\workspace\\idea\\spring-boot-hello-world\\target\\classes started by fanlychie in F:\\dev\\workspace\\idea\\spring-boot-hello-world)2017-10-12 13:02:06.793 INFO 7188 --- [ main] com.hk.Application : No active profile set, falling back to default profiles: default2017-10-12 13:02:06.844 INFO 7188 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-10-12 13:02:08.030 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-10-12 13:02:08.041 INFO 7188 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-10-12 13:02:08.042 INFO 7188 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-10-12 13:02:08.121 INFO 7188 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-10-12 13:02:08.122 INFO 7188 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1284 ms2017-10-12 13:02:08.254 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/]2017-10-12 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*]2017-10-12 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]2017-10-12 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*]2017-10-12 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*]2017-10-12 13:02:08.502 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-10-12 13:02:08.597 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/],methods=[GET]&#125;\" onto public java.lang.String com.hk.controller.HelloWorldController.sayHello()2017-10-12 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error]&#125;\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-10-12 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error],produces=[text/html]&#125;\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-10-12 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-12 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-12 13:02:08.661 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-10-12 13:02:08.826 INFO 7188 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-10-12 13:02:08.866 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-10-12 13:02:08.869 INFO 7188 --- [ main] com.hk.Application : Started Application in 2.338 seconds (JVM running for 2.673)","tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"https://huankai.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 添加 Thymeleaf 支持","date":"2018-02-22T07:15:02.791Z","path":"2018/02/22/Spring_Boot_02/","text":"Spring Boot 对 Thymeleaf 模板引擎提供了自配置的良好支持。Spring Boot 1.5.7.RELEASE 版本默认使用的是 Thymeleaf 2.0+，本文使用 Thymeleaf 3.0+ 版本，在 pom.xml 中添加以下声明： 1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.5.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 然后在 dependencies 添加 Thymeleaf 依赖声明: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 控制器:123456789@Controllerpublic class WelcomeController &#123; @GetMapping(\"/\") public String welcome(ModelMap model) &#123; model.put(\"message\", \"Hello Thymeleaf!\"); return \"index\"; &#125;&#125; 模板文件: Spring Boot 对 Thymeleaf 模板引擎提供了自动配置的支持(详见 ThymeleafProperties)。我们只需遵循约定，在/src/main/resources/templates/目录创建相应的页面模板文件（*.html）即可 #src/main/resources/templates/index.html 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@&#123;/css/main.css&#125;\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=\"$&#123;message&#125;\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 静态文件:Spring Boot 默认将静态资源文件映射到类路径下的目录包括(详见 ResourcesProperties)： /META-INF/resources/ /resources/ /static/ /public/ 因此我们可以将 css、js、images 等静态资源文件放在/src/main/resources/static/目录下. #src/main/resources/static/css/main.css123456789body &#123; padding: 0; color: #444; width: 280px; margin: 100px auto; font-family: SimSun; background-color: #FBFBFB; text-shadow: rgba(50,50,50,0.3) 2px 2px 3px;&#125; 主应用程序类: 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 模板文件和静态资源文件的缓存问题: 当修改 css、js 等静态资源文件的内容或模板文件的内容时，刷新客户端浏览器，发现内容还是老的，说明 Spring Boot 内置的 Servelt 容器并没有实时重新加载修改过的文件内容。你只能在每次修改静态资源文件时，虽然不需要重启服务，但是你要重新编译一次，IntelliJ IDEA 中按一次 Ctrl + F9 即可。 有关 Thymeleaf 基本使用可查看 Thymeleaf 教程","tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"https://huankai.github.io/tags/Spring-Boot/"}]},{"title":"SecureCRT 8.1 安装与破解","date":"2018-02-22T07:15:02.783Z","path":"2018/02/22/SecureCRT_8_1/","text":"一、安装下载地址： 百度云盘链接 ，密码 ： dfit 安装直接按步骤下一步完成即可，这里略过 二、破解先不要启动程序，将 keygen.exe与 fx.exe文件复制到安装目录下 右键 keygen.exe 以管理员运行如下 ： 点击 patch,弹出对话框，选中 SecureCRT.exe 文件，再点击 Generate，选择 LicenseHelper.exe 文件，破解 SecureCRT。 右键 fx.exe 以管理员运行如下 ：123Name 输入上面的 name,如： ygeRCompany 输入上面的 Company,如： TEAM ZWT点击Patch --&gt; Generate 然后打开SecureCRT 和 SecureFX，将上面生成的信息输入分别到指定的输入框中，完成破解。注意：keygen.exe生成的信息是破解 SecureCRT 的，fx.exe生成的信息是破解 SecureFX 的。 三、设置编码 SecureCRT编码设置：打开 SecureCRT软件，Options –&gt; Session Options : &nbsp;&nbsp; 如上，设置为UTF-8 SecureFX编码设置：打开 SecureFX软件，Options –&gt; Session Options : 还需要修改配置文件：Options -&gt; Global Options -&gt; General -&gt; Configuraition Paths : 找到配置文件所在目录的Sesseion目录 修改Default.ini配置内容找到 Use UTF8”=00000000 ，将00000000 改为 00000001 接下来新创建的连接就是以UTF8编码的了，如果之前已创建的连接，还是有乱码问题，找到此目录下指定的ip地址的 ini文件，如 192.168.1.244.ini 文件，查看是否 Use UTF8 行值为 00000000，改为 00000001","tags":[{"name":"Tool","slug":"Tool","permalink":"https://huankai.github.io/tags/Tool/"}]},{"title":"Redis 事务","date":"2018-02-22T07:15:02.777Z","path":"2018/02/22/Redis_05_事务/","text":"1、介绍：redis 事务 ：可以一次执行多个命令，本质上是一组命令的集合。具有如下两个特性： 一个事务中的所有命令都会被序列化，按顺序串行化执行， 在执行的过程中，不会被其它客户端发送的命令所打断。 事务是一个原子操作，要么全部执行，要么全部不执行。 EXEC 命令负责触发并执行事务中的所有命令： 如果客户端的使用 MULTI 开启一个事务后，因为断开而没有成功执行EXEC，那么事务中的所有命令都不会被执行； 如果客户端在开启事务之后，执行EXEC，那么事务中的所有命令都会执行。 当使用 AOF 做持久化时，Redis 会使用单个Write(2)命令将事务写入到磁盘中。如果Redis服务器因为某种原因被管理员杀死，或者遇到某种故障，可能只有部分事务命令被写入磁盘中。 2、事务常用命令： 命令 开始版本 描述 MULTI 1.2.0 标记一个事务块的开始。 随后的指令将在执行EXEC时作为一个原子执行 EXEC 1.2.0 执行事务中所有在排队等待的指令并将链接状态恢复到正常,当使用WATCH 时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行 DISCARD 2.0.0 刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常 WATCH 2.2.0 标记所有指定的key 被监视起来，在事务中有条件的执行（乐观锁） UNWATCH 2.2.0 刷新一个事务中已被监视的所有key 2.1、正常执行1234567891011121314151617181920[root@huangkai ~]# redis-cli 127.0.0.1:6379&gt; 127.0.0.1:6379&gt; 127.0.0.1:6379&gt; 127.0.0.1:6379&gt; KEYS *(empty list or set)127.0.0.1:6379&gt; 127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 k1QUEUED127.0.0.1:6379&gt; set k2 k2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; EXEC1) OK2) OK3) \"k2\"127.0.0.1:6379&gt; 2.2、放弃事务使用 DISCARD 放弃事务后，EXEC 将抛出错误12345678910111213141516171819127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; KEYS *(empty list or set)127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 k1QUEUED127.0.0.1:6379&gt; set k2 k2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; DISCARDOK127.0.0.1:6379&gt; EXEC(error) ERR EXEC without MULTI127.0.0.1:6379&gt; get k1(nil)127.0.0.1:6379&gt; 2.3、全体连坐当执行错误的命令时，redis抛出异常信息，再执行 EXEC 时，也会抛出执行失败的错误信息，此时事务会回滚。1234567891011121314151617127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 k1QUEUED127.0.0.1:6379&gt; set k2 k2QUEUED127.0.0.1:6379&gt; sets k3(error) ERR unknown command 'sets'127.0.0.1:6379&gt; set k4 k4QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k1(nil)127.0.0.1:6379&gt; 2.4、冤头债主先设置 k1 值为 k1，k2 值为 k2，再对 k1执行原子加1操作，显示 (k1 + 1)无法运算，但是在进行 INCR 时，并没有抛出异常，而在 EXEC 时有异常，此时事务并没有回滚，只是异常出现的地方没有执行而已。可知 Redis事务并不是很严谨，可以说Redis只是支持部分事务。123456789101112131415161718127.0.0.1:6379&gt; FLUSHDBOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; set k1 k1QUEUED127.0.0.1:6379&gt; set k2 k2QUEUED127.0.0.1:6379&gt; INCR k1QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; EXEC1) OK2) OK3) (error) ERR value is not an integer or out of range4) \"k1\"127.0.0.1:6379&gt; 2.5、Watch监控实现乐观锁WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消。 什么是悲观锁? &nbsp;&nbsp;悲观锁(Pessimistic Lock): 就是很悲观，每次去拿数据时都会认识别人会修改，所以每次去拿数据时都会加锁，这样别人拿到数据就会block直到它拿到锁。传统的关系型数据库就用到很多这种锁机制，如表锁，行锁，读锁，写锁等，都是在操作之前先上锁。常用场景如备份数据库表时，锁整个表。 什么是乐观锁? &nbsp;&nbsp;乐观锁(Optimistic Lock) :就是很乐观，每次去拿数据时都会认识别人不会修改，所以不会加锁，但是在更新的时候，会判断别人在此期间是否有更新数据，可以使用版本号等机会，乐观锁适用于多读的应用类型，这样可以提高系统吞吐量。乐观锁策略：提交版本号必须大于记录当前版本号才能执行更新。 CAS(Check And Set)这里引用官网的例子说明， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）首先我们可能会这样做：123val = GET mykeyval = val + 1SET mykey val 上面的这个实现在只有一个客户端的时候可以很好地执行。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。有了 WATCH ， 我们就可以轻松地解决这类问题了： 123456WATCH mykeyval = GET mykeyval = val + 1MULTISET mykey valEXEC 使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。 WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：12127.0.0.1:6379&gt; WATCH key1 key2 OK 当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。 另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。 使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。","tags":[{"name":"Redis","slug":"Redis","permalink":"https://huankai.github.io/tags/Redis/"}]},{"title":"Redis 发布与订阅","date":"2018-02-22T07:15:02.770Z","path":"2018/02/22/Redis_04_发布与订阅/","text":"Redis发布与订阅 订阅，取消订阅和发布实现了发布/订阅消息范式，发送者（发布者）不是计划发送消息给特定的接收者（订阅者）。而是发布的消息分到不同的频道，不需要知道什么样的订阅者订阅。订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。 Redis的发布与订阅功能说白了就是消息，它支持消息功能 ，但是在企业开发中一般不会选择使用Redis的发布与订阅，而会选择消息中间件，如 ActiveMq、RabbitMq 、RocketMq 、Kafka等。在企业开发中Redis的主要还是作为分布式内存缓存使用。 发布与订阅命令： 命令 语法 开始版本 描述 PSUBSCRIBE PSUBSCRIBE pattern [pattern …] 2.0.0 订阅给定的模式(patterns) PUBSUB PUBSUB subcommand [argument [argument …]] 2.8.0 PUBSUB是一个内省命令，允许检查Pub / Sub子系统的状态。它由单独记录的子命令组成 PUBLISH PUBLISH channel message 2.0.0 将信息 message 发送到指定的频道 channe PUNSUBSCRIBE PUNSUBSCRIBE [pattern [pattern …]] 2.0.0 停止发布到匹配给定模式的渠道的消息监听 SUBSCRIBE SUBSCRIBE channel [channel …] 2.0.0 订阅给指定频道的信息 UNSUBSCRIBE UNSUBSCRIBE [channel [channel …]] 2.0.0 停止频道监听 1、SUBSCRIBE(订阅频道)一个客户端订阅 频道 channel1 与 channel2 2、PUBLISH(发布消息)在 channel1 发布消息 hello 此时订阅了 channel1频道的客户端将收到发送的消息，见 第一张图片 3、PSUBSCRIBE(通配符订阅模式)通配符订阅以 new 开头的频道 发送消息到 new1 和 new13 频道，上面可以收到信息","tags":[{"name":"Redis","slug":"Redis","permalink":"https://huankai.github.io/tags/Redis/"}]},{"title":"Redis 持久化","date":"2018-02-22T07:15:02.763Z","path":"2018/02/22/Redis_03_持久化/","text":"","tags":[{"name":"Redis","slug":"Redis","permalink":"https://huankai.github.io/tags/Redis/"}]},{"title":"Redis配置文件","date":"2018-02-22T07:15:02.757Z","path":"2018/02/22/Redis_02_配置文件/","text":"Redis 的主配置文件在 Redis安装根目录下redis.conf，文件详细配置如下： 配置文件单位说明： 1k =&gt; 1000 bytes 1kb =&gt; 1024 bytes 1m =&gt; 1000000 bytes 1mb =&gt; 1024*1024 bytes 1g =&gt; 1000000000 bytes 1gb =&gt; 102410241024 bytes如上可知， 1g 与 1gb所表示的大小是有区别的，单位大小写不敏感，1gb = 1Gb = 1gB = 1GB 1、includes载入其它配置文件信息比如说当你有多个server，而有一些配置项是它们公用的，那么你可以将这些公用的配置项写进一个配置文件common.conf里，然后这些server再include这个配置文件，这些server自己的配置项则分别写在自己的配置文件里。示例：include /path/to/common.conf 2、modules模块系统，是Redis 4.0新功能之一。这个系统可以让用户通过自己编写的代码来扩展和实现 Redis 本身并不具备的功能， 具体使用方法可以参考 antirez 的博文《Redis Loadable Module System》： http://antirez.com/news/106 因为模块系统是通过高层次 API 实现的， 它与 Redis 内核本身完全分离、互不干扰， 所以用户可以在有需要的情况下才启用这个功能， 以下是 redis.conf 中记载的模块载入方法：1234567################################## MODULES ###################################### Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so 目前已经有人使用这个功能开发了各种各样的模块， 比如 Redis Labs 开发的一些模块就可以在 http://redismodules.com 看到， 此外 antirez 自己也使用这个功能开发了一个神经网络模块： https://github.com/antirez/neural-redis模块功能使得用户可以将 Redis 用作基础设施， 并在上面构建更多功能， 这给 Redis 带来了无数新的可能性。 3、network123456789################################## NETWORK #####################################bind 127.0.0.1 192.168.1.90protected-mode yesport 6379tcp-backlog 511# unixsocket /tmp/redis.sock# unixsocketperm 700timeout 0tcp-keepalive 300 3.1、bind默认情况下,bind接口是127.0.0.1，也就是本地回环地址，这样，Redis只能通过本机客户端连接，而无法通过远程连接，这样可以避免将redis服务暴露于危险的网络环境中，防止一些不安全的人随随便便通过远程连接到redis服务。如果bind选项为空的话，并且 protected-mode 为 no，会接受所有来自于可用网络接口的连接。如果bind选项为空的话，并且 protected-mode 为 yes，会选择默认的连接，即只能通过 127.0.0.1连接语法如下： 1bind ip1 ip2 ... 如果redis安装服务器ip为 192.168.1.90 ，在 192.168.1.4机器 上需要连接 redis服务，那么 bind配置应该如下123#注意，后面的ip并不是配置 192.168.1.4，应该配置redis可接受的ip 192.168.1.90bind 127.0.0.1 192.168.1.90protected-mode yes 或者如下：1protected-mode no 3.2、protected-mode保护模式：默认为 yes,只接受指定 bind的连接，如果设置为 no ，bind的ip不会生效，接受所有可用的网络连接。生产环境严格建议设置为 yes 3.3、portredis配置服务的端口号参数 3.4、timeout客户端连接超时时间，单位为秒，0 为禁止 4、GENERAL12345678910################################# GENERAL #####################################daemonize yessupervised nopidfile /var/run/redis_6379.pidloglevel noticelogfile \"\"syslog-enabled nosyslog-ident redissyslog-facility local0databases 16 4.1、daemonizeredis是否以守护进程启动，默认为 no，可选值 yes | no 4.2、supervised可以通过upstart和systemd管理Redis守护进程，这个参数是和具体的操作系统相关的 4.3、pidfileredis启动后的pid文件目录，默认为 /var/run/redis_6379.pid 4.4、loglevel日志级别：有四个等级 ：debug &lt; verbose &lt; notice &lt; warning ,默认为 notice 4.5、logfile日志文件目录，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到 /dev/null 4.6、 syslog-enabled是否把日志记录到系统日志。默认为 no 4.7、syslog-ident设置系统日志的id 4.8、syslog-facility指定syslog设备(facility)，必须是user或则local0到local7 4.9、databasesredis database 个数，默认为 16 个，从 0 开始 ，到 15 5、SNAPSHOTTING快照配置12345678save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir ./ 5.1、saverdb持久化每隔 多少 秒内有 多少个写操作，执行持久化操作,可以配置多个save ,如果要禁rdb，这里的三个 save都注释就可以了. 5.2、stop-writes-on-bgsave-errorrdb持久化,redis会在持久化的时候，开启一个新的进程进行持久化，如果在持久化的时候出错，如磁盘空间不足，为保证数据的完整性，此参数控制持久化出错时停止在内存写入数据。默认值就好。 5.3、rdbcompressionrdb 持久化时是否压缩，默认yes 5.4、rdbchecksum重启redis时，检查 rdb文件是否有损坏，默认 yes 5.5、dbfilename存的 rdb文件名，默认为 dump.rdb 5.6、dir导出的rdb文件放在哪个目录，默认为当前目录 6、REPLICATION主从复制12345678910111213141516slaveof &lt;masterip&gt; &lt;masterport&gt;masterauth &lt;master-password&gt;slave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-ping-slave-period 10repl-timeout 60repl-disable-tcp-nodelay norepl-backlog-size 1mbrepl-backlog-ttl 3600slave-priority 100min-slaves-to-write 3min-slaves-max-lag 10slave-announce-ip 5.5.5.5slave-announce-port 1234 6.1、slaveof设置本机为slave服务。格式：slaveof 。设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步。1slave 192.168.1.90 6378 6.2、masterauth当master服务设置了密码保护时，slav服务连接master的密码。 6.3、slave-serve-stale-data当一个slave与master失去联系时，或者复制正在进行的时候，slave应对请求的行为：1) 如果为 yes（默认值） ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候；2) 如果为 no ，在你执行除了 info 和 salveof 之外的其他命令时，slave 都将返回一个 “SYNC with master in progress” 的错误。 6.4、slave-read-only设置slave是否是只读的。从2.6版起，slave默认是只读的。 6.5、repl-diskless-sync主从数据复制是否使用无硬盘复制功能。 6.6、repl-diskless-sync-delay当启用磁盘复制时，可以配置延迟时间，以秒为单位，默认为 5 秒，如果设置为 0 ，表示禁用。 6.7、repl-ping-slave-period指定slave定期ping master的周期，默认10秒钟。 6.8、repl-timeout设置主库批量数据传输时间或者ping回复时间间隔，默认值是60秒 。 6.9、repl-disable-tcp-nodelay指定向slave同步数据时，是否禁用socket的NO_DELAY选项。若配置为“yes”，则禁用NO_DELAY，则TCP协议栈会合并小包统一发送，这样可以减少主从节点间的包数量并节省带宽，但会增加数据同步到 slave的时间。若配置为“no”，表明启用NO_DELAY，则TCP协议栈不会延迟小包的发送时机，这样数据同步的延时会减少，但需要更大的带宽。 通常情况下，应该配置为no以降低同步延时，但在主从节点间网络负载已经很高的情况下，可以配置为yes 6.10、repl-backlog-size设置主从复制backlog容量大小。这个 backlog 是一个用来在 slaves 被断开连接时存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。这个值越大，salve 可以断开连接的时间就越长。 6.11、repl-backlog-ttl配置当master和slave失去联系多少秒之后，清空backlog释放空间。当配置成0时，表示永远不清空。 6.12、slave-priority当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。 默认优先级为 100。 6.13、min-slaves-to-write首先在本机启动两台redis服务192.168.1.90 6379(master)192.168.1.90 6378(slave)1234567891011121314151617[root@huangkai ~]# redis-cli 127.0.0.1:6379&gt; 127.0.0.1:6379&gt; 127.0.0.1:6379&gt; INFO replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6378,state=online,offset=182,lag=1master_replid:5af7d4dbd0be4052451940ed582c66244dee38b3master_replid2:0000000000000000000000000000000000000000master_repl_offset:182second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:182127.0.0.1:6379&gt; 在master服务中使用info查看信息如上：可以看到有一个slave,端口号为 6378，在一般情况下，lag的值应该在0秒或者1秒之间跳动，如果超过1秒的话，那么说明主从服务器之间的连接出现了故障。 Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令12min-slaves-to-write 3min-slaves-max-lag 10 那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值。默认情况下 min-slaves-to-write 值为 0 (禁用) ，min-slaves-max-lag 值为 10. 6.14、min-slaves-max-lag见 6.13 6.15、slave-announce-ipRedis master能够以不同的方式列出所连接slave的地址和端口。例如，“INFO replication”部分提供此信息，除了其他工具之外，Redis Sentinel还使用该信息来发现slave实例。此信息可用的另一个地方在masterser的“ROLE”命令的输出中。通常由slave报告的列出的IP和地址,通过以下方式获得：IP：通过检查slave与master连接使用的套接字的对等体地址自动检测地址。端口：端口在复制握手期间由slavet通信，并且通常是slave正在使用列出连接的端口。然而，当使用端口转发或网络地址转换（NAT）时，slave实际上可以通过(不同的IP和端口对)来到达。 slave可以使用以下两个选项，以便向master报告一组特定的IP和端口，以便INFO和ROLE将报告这些值。如果你需要仅覆盖端口或IP地址，则没必要使用这两个选项。 6.16、slave-announce-port见 6.15 7、SECURITY安全配置12requirepass foobaredrename-command CONFIG \"\" 7.1、requirepass设置redis连接密码，生产环境强烈建议设置密码。 7.2、rename-command将命令重命名。为了安全考虑，可以将某些重要的、危险的命令重命名。当你把某个命令重命名成空字符串的时候就等于取消了这个命令。 8、CLIENTS客户端配置1maxclients 10000 此类只有一个参数，maxclients ,设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数-32（redis server自身会使用一些），如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息。 9、 MEMORY MANAGEMENT内存管理123maxmemory &lt;bytes&gt;maxmemory-policy noevictionmaxmemory-samples 5 9.1、maxmemory指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区，格式：maxmemory 。1maxmemory 1024000 9.2、maxmemory-policy当内存使用达到最大值时，redis使用的清除策略。有以下几种可以选择： volatile-lru -&gt; 利用LRU算法移除设置过过期时间的key (LRU:最近最少使用 Least Recently Used ,也就是首先淘汰最长时间未被使用的key) allkeys-lru -&gt; 利用LRU算法移除任何key volatile-lfu -&gt; 利用LFU算法移除设置过过期时间的key(LFU:最近最不常用 Least Frequently Used,也就是淘汰一定时期内被访问次数最少的 key) allkeys-lfu -&gt; 利用LFU算法移除任何key volatile-random -&gt; 移除设置过过期时间的随机key allkeys-random -&gt; 移除随机key volatile-ttl -&gt; 移除即将过期的key(minor TTL) noeviction -&gt; 不移除任何key，只是返回一个写错误 。默认选项 9.3、maxmemory-samplesLRU、LFU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)，随意你可以选择样本大小进行检测。redis默认选择5个样本进行检测，你可以通过maxmemory-samples进行设置 样本数 10、 LAZY FREEING1234lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noslave-lazy-flush no 11、APPEND ONLY MODEAOF 持久化，将每执行的命令写入文件中，默认为 no，可以和rdb一起使用使用 aof有一个问题：当对同一个key多次更改时，其实我们只需要最后一次更新的值，之前执行的命令也会保存起来，这样会导致aof文件过大。12345678appendonly noappendfilename \"appendonly.aof\"appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yesaof-use-rdb-preamble no 11.1、appendonly是否启用aof持久化方式 。即是否在每次更新操作后进行日志记录，默认配置是no，即在采用异步方式把数据写入到磁盘。可选值 no | yes 11.2、appendfilenameaof持久化文件名，默认为 appendonly.aof 11.3、appendfsyncaof文件刷新的频率。有三种： always ：在每个命令都会同步到 aof文件中，安全，速度慢，因为要经常操作磁盘; everysec : 择中方案，每秒写一次，最多也只会丢失1秒的数据，默认值; no : 由操作系统判断缓存大小写入到磁盘,同步频率低，速度快。 11.4、no-appendfsync-on-rewrite正在导出 rdb 快照的过程中要不要停止同步aof 默认为 no，默认值即可 11.5、auto-aof-rewrite-percentageaof重写参数对于使用aof持久化时，操作同一个Key导致aof文件过大的问题，可以使用auto-aof-rewrite-percentage 与 auto-aof-rewrite-min-size 两个参数来设定。 aof 文件大小比上次重写时的大小，增长率达到 100%时重写1auto-aof-rewrite-percentage 100 11.6、auto-aof-rewrite-min-sizeaof文件会从 0 M 增长，前期 aof会进行大量的重写，在此时间没有必须这么频繁的重写，这里指定aof文件超过 64M时才重写，和上面的 auto-aof-rewrite-percentage 参数是并的关系1auto-aof-rewrite-min-size 64mb 11.7、aof-load-truncatedredis在启动时可以加载被截断的AOF文件，而不需要先执行 redis-check-aof 工具1aof-load-truncated yes 11.8、aof-use-rdb-preambleRedis 4.0 新增了 RDB-AOF 混合持久化格式这是一个可选的功能， 在开启了这个功能之后， AOF 重写产生的文件将同时包含 RDB 格式的内容和 AOF 格式的内容， 其中 RDB 格式的内容用于记录已有的数据， 而 AOF 格式的内存则用于记录最近发生了变化的数据， 这样 Redis 就可以同时兼有 RDB 持久化和 AOF 持久化的优点 —— 既能够快速地生成重写文件， 也能够在出现问题时， 快速地载入数据。这个功能可以通过此参数进行开启,默认为 no 12、 LUA SCRIPTINGLUA脚本1lua-time-limit 5000 此类只有一个参数 lua-time-limit,一个Lua脚本最长的执行时间，单位为毫秒，如果为0或负数表示无限执行时间，默认为5000。 13、REDIS CLUSTERRedis集群配置123456cluster-enabled yescluster-config-file nodes-6379.confcluster-node-timeout 15000cluster-slave-validity-factor 10cluster-migration-barrier 1cluster-require-full-coverage yes 13.1、cluster-enabled集群开关，默认不开启集群模式 13.2、cluster-config-file集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件请确保与实例运行的系统中配置文件名称不冲突1cluster-config-file nodes-6379.conf 13.3、cluster-node-timeout节点互连超时的阀值，集群节点超时毫秒数 13.4、cluster-slave-validity-factor在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period,如果节点超时时间为三十秒, 并且slave-validity-factor为10,,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移 13.5、cluster-migration-barriermaster的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。 13.6、cluster-require-full-coverage默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致 14、 CLUSTER DOCKER/NAT support兼容 NAT 和 Docker，4.0 新功能123cluster-announce-ip 10.1.1.5cluster-announce-port 6379cluster-announce-bus-port 6380 15、SLOW LOGslowlog是redis用于记录记录慢查询执行时间的日志系统。由于slowlog只保存在内存中，因此slowlog的效率很高，完全不用担心会影响到redis的性能。12slowlog-log-slower-than 10000slowlog-max-len 128 15.1、slowlog-log-slower-thanslowlog的划定界限，只有query执行时间大于slowlog-log-slower-than的才会定义成慢查询，才会被slowlog进行记录。slowlog-log-slower-than设置的单位是微妙，默认是10000微妙，也就是10ms 15.2、slowlog-max-len慢查询最大的条数，当slowlog超过设定的最大值后，会将最早的slowlog删除，是个FIFO队列 16、LATENCY MONITOR延迟监控延迟监控功能是用来监控redis中执行比较缓慢的一些操作，用LATENCY打印redis实例在跑命令时的耗时图表。只有一个参数 latency-monitor-threshold ，只记录大于等于设置的值的操作，0的话，就是关闭监视1latency-monitor-threshold 0 17、EVENT NOTIFICATION事件通知1notify-keyspace-events Elg 17.1、notify-keyspace-events键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。notify-keyspace-events 的参数可以是以下字符的任意组合，它指定了服务器该发送哪些类型的通知： K 键空间通知，所有通知以 __keyspace@__ 为前缀 E 键事件通知，所有通知以 __keyevent@__ 为前缀 g DEL、 EXPIRE 、 RENAME 等类型无关的通用命令的通知 $ 字符串命令的通知 l 列表命令的通知 s 集合命令的通知 h 哈希命令的通知 z 有序集合命令的通知 x 过期事件：每当有过期键被删除时发送 e 驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送 A 参数 g$lshzxe 的别名 输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何 通知被分发。示例如下 ：1notify-keyspace-events Elg 18、 ADVANCED CONFIG高级配置 1234567891011121314hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yes 18.1、hash-max-ziplist-entrieshash类型的数据结构在编码上可以使用ziplist和hashtable。ziplist的特点就是文件存储(以及内存存储)所需的空间较小,在内容较小时,性能和hashtable几乎一样。因此redis对hash类型默认采取ziplist。如果hash中条目的条目个数或者value长度达到阀值,将会被重构为hashtable。这个参数指的是ziplist中允许存储的最大条目个数，，默认为512，建议为1281hash-max-ziplist-entries 128 18.2、hash-max-ziplist-valueziplist中允许条目value值最大字节数，默认为64，建议为10241hash-max-ziplist-value 1024 18.3、list-max-ziplist-size当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下： -5 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes） -4 每个quicklist节点上的ziplist大小不能超过32 Kb。 -3 每个quicklist节点上的ziplist大小不能超过16 Kb。 -2 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值） -1 每个quicklist节点上的ziplist大小不能超过4 Kb 18.4、list-compress-depth这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。参数list-compress-depth的取值含义如下： 0: 是个特殊值，表示都不压缩。这是Redis的默认值。 1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。 2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。 3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。依此类推… 由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取 18.4、set-max-intset-entriesset允许存储的最大条目个数小于等于set-max-intset-entries用intset，大于set-max-intset-entries用set 18.5、zset-max-ziplist-entrieszset中允许存储的最大条目个数小于等于zset-max-ziplist-entries用ziplist，大于zset-max-ziplist-entries用zset 18.6、zset-max-ziplist-valuezset中允许的value值最大字节数小于等于zset-max-ziplist-value用ziplist，大于zset-max-ziplist-value用zset 18.7、hll-sparse-max-bytes设置的值小于等于hll-sparse-max-bytes使用稀疏数据结构（sparse）大于hll-sparse-max-bytes使用稠密的数据结构（dense），取值范围在 0 ~ 15000，建议的value大概为3000。如果对CPU要求不高，对空间要求较高的，建议设置到10000左右 18.8、activerehashingRedis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存 18.9、client-output-buffer-limit normal对客户端输出缓冲进行限制可以强迫那些不从服务器读取数据的客户端断开连接，用来强制关闭传输缓慢的客户端。1client-output-buffer-limit normal 0 0 0 对于normal client，第一个0表示取消hard limit，第二个0和第三个0表示取消soft limit，normal client默认取消限制，因为如果没有寻问，他们是不会接收数据的 18.10、client-output-buffer-limit1client-output-buffer-limit slave 256mb 64mb 60 对于slave client和MONITER client，如果client-output-buffer一旦超过256mb，又或者超过64mb持续60秒，那么服务器就会立即断开客户端连接 18.11、client-output-buffer-limit1client-output-buffer-limit pubsub 32mb 8mb 60 对于pubsub client，如果client-output-buffer一旦超过32mb，又或者超过8mb持续60秒，那么服务器就会立即断开客户端连接 18.12、hz1hz 10 redis执行任务的频率为1s除以hz ，如 1/10 18.13、aof-rewrite-incremental-fsync1aof-rewrite-incremental-fsync yes 在aof重写的时候，如果打开了aof-rewrite-incremental-fsync开关，系统会每32MB执行一次fsync。这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值 19、ACTIVE DEFRAGMENTATION活跃的碎片整理注意，此功能在 此系列教程使用的版本中只是实验性的，您也可以无视它。然而，即使是在生产过程中，它也经受了压力测试，并由多名工程师手工测试了一段时间。 什么是活跃的碎片整理？活动(联机)碎片整理允许Redis服务器压缩内存中数据的小分配和deal位置之间的空间，从而恢复内存。 碎片化是一个自然过程，每一个分配器和某些工作负载都会发生。通常需要重新启动服务器以降低碎片，或者至少清除所有数据并重新创建它。然而，由于Oran Agra实现了Redis 4.0的这个特性，这个过程在运行时可以在运行时以“热”的方式运行。 在redis运行的情况下，此功能默认是禁用的，只有在编译Redis时才会开启。123456activedefrag yesactive-defrag-ignore-bytes 100mbactive-defrag-threshold-lower 10active-defrag-threshold-upper 100active-defrag-cycle-min 25active-defrag-cycle-max 75 19.1、activedefrag1activedefrag yes 启用碎片整理 19.1、active-defrag-ignore-bytes碎片垃圾开始主动整理的最低大小 19.2、active-defrag-threshold-lower碎片开始自动整理的最小百分比 19.3、active-defrag-threshold-upper最大化碎片率 19.4、active-defrag-cycle-min最小整理磁盘碎片的CPU百分比 19.5、active-defrag-cycle-max最大整理磁盘碎片的CPU百分比","tags":[{"name":"Redis","slug":"Redis","permalink":"https://huankai.github.io/tags/Redis/"}]},{"title":"Redis安装","date":"2018-02-22T07:15:02.750Z","path":"2018/02/22/Redis_01_安装教程/","text":"安装环境 系统版本：CentOS Linux release 7.3.1611 (Core) Redis版本：4.0.1 下载下载地址： 请点击 官网 下载 ，下载完成后，上传到 Linux某个目录中。 也可以直接使用 wget 命令下载： 12345678910111213[huangkai@sjq01 soft]$ wget http://download.redis.io/releases/redis-4.0.1.tar.gz--2017-10-20 14:10:53-- http://download.redis.io/releases/redis-4.0.1.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1711660 (1.6M) [application/x-gzip]Saving to: ‘redis-4.0.1.tar.gz’100%[===============================================================================================================================================================================================&gt;] 1,711,660 585KB/s in 2.9s 2017-10-20 14:10:57 (585 KB/s) - ‘redis-4.0.1.tar.gz’ saved [1711660/1711660][huangkai@sjq01 soft]$ lltotal 1672-rw-rw-r--. 1 huangkai huangkai 1711660 Jul 24 21:59 redis-4.0.1.tar.gz 12345678910111213[huangkai@sjq01 soft]$ wget http://download.redis.io/releases/redis-4.0.1.tar.gz--2017-10-20 14:10:53-- http://download.redis.io/releases/redis-4.0.1.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1711660 (1.6M) [application/x-gzip]Saving to: ‘redis-4.0.1.tar.gz’100%[===============================================================================================================================================================================================&gt;] 1,711,660 585KB/s in 2.9s 2017-10-20 14:10:57 (585 KB/s) - ‘redis-4.0.1.tar.gz’ saved [1711660/1711660][huangkai@sjq01 soft]$ lltotal 1672-rw-rw-r--. 1 huangkai huangkai 1711660 Jul 24 21:59 redis-4.0.1.tar.gz 安装1、解压文件解压文件到指定目录 (/usr/local/) 1234567891011121314151617181920212223[huangkai@sjq01 soft]$ sudo tar xzf redis-4.0.1.tar.gz -C /usr/local/[sudo] password for huangkai: [huangkai@sjq01 soft]$ cd /usr/local/redis-4.0.1[huangkai@sjq01 redis-4.0.1]$ lltotal 268-rw-rw-r--. 1 huangkai huangkai 127778 Jul 24 21:58 00-RELEASENOTES-rw-rw-r--. 1 huangkai huangkai 53 Jul 24 21:58 BUGS-rw-rw-r--. 1 huangkai huangkai 1815 Jul 24 21:58 CONTRIBUTING-rw-rw-r--. 1 huangkai huangkai 1487 Jul 24 21:58 COPYINGdrwxrwxr-x. 6 huangkai huangkai 124 Jul 24 21:58 deps-rw-rw-r--. 1 huangkai huangkai 11 Jul 24 21:58 INSTALL-rw-rw-r--. 1 huangkai huangkai 151 Jul 24 21:58 Makefile-rw-rw-r--. 1 huangkai huangkai 4223 Jul 24 21:58 MANIFESTO-rw-rw-r--. 1 huangkai huangkai 20530 Jul 24 21:58 README.md-rw-rw-r--. 1 huangkai huangkai 57764 Jul 24 21:58 redis.conf-rwxrwxr-x. 1 huangkai huangkai 271 Jul 24 21:58 runtest-rwxrwxr-x. 1 huangkai huangkai 280 Jul 24 21:58 runtest-cluster-rwxrwxr-x. 1 huangkai huangkai 281 Jul 24 21:58 runtest-sentinel-rw-rw-r--. 1 huangkai huangkai 7606 Jul 24 21:58 sentinel.confdrwxrwxr-x. 3 huangkai huangkai 4096 Jul 24 21:58 srcdrwxrwxr-x. 10 huangkai huangkai 167 Jul 24 21:58 testsdrwxrwxr-x. 8 huangkai huangkai 4096 Jul 24 21:58 utils[huangkai@sjq01 redis-4.0.1]$ 如上所示， tar 命令 -C 参数，表示把 tar.gz包解压到 /usr/local目录中，上面需要输入密码，是因为/usr/local目录需要root用户才能访问，此时并不是root用户登陆。2、赋予权限(可选操作) 给当前用户redis操作的权限(可选，如果你安装的目录普通用户有权限访问，或者你使用的是root用户，此操作不需要，如果没有权限，后面的操作可能都会报没有权限的错误) 将redis-4.0.1目录及其子目录的所有者给 huangkai 1234567891011121314[root@sjq01 local]# chown -R huangkai:huangkai redis-4.0.1[root@sjq01 local]# lltotal 4drwxr-xr-x. 2 root root 6 Nov 5 2016 bindrwxr-xr-x. 2 root root 6 Nov 5 2016 etcdrwxr-xr-x. 2 root root 6 Nov 5 2016 gamesdrwxr-xr-x. 2 root root 6 Nov 5 2016 includedrwxr-xr-x. 2 root root 6 Nov 5 2016 libdrwxr-xr-x. 2 root root 6 Nov 5 2016 lib64drwxr-xr-x. 2 root root 6 Nov 5 2016 libexecdrwxrwxr-x. 6 huangkai huangkai 4096 Jul 24 21:58 redis-4.0.1drwxr-xr-x. 2 root root 6 Nov 5 2016 sbindrwxr-xr-x. 5 root root 49 Aug 16 09:08 sharedrwxr-xr-x. 2 root root 6 Nov 5 2016 src 3、创建安装目录 (bin 和 conf)：1234567891011121314151617181920212223[huangkai@sjq01 redis-4.0.1]$ mkdir bin conf[huangkai@sjq01 redis-4.0.1]$ lltotal 268-rw-rw-r--. 1 huangkai huangkai 127778 Jul 24 21:58 00-RELEASENOTESdrwxrwxr-x. 2 huangkai huangkai 6 Oct 20 15:36 bin-rw-rw-r--. 1 huangkai huangkai 53 Jul 24 21:58 BUGS-rw-rw-r--. 1 huangkai huangkai 1815 Jul 24 21:58 CONTRIBUTING-rw-rw-r--. 1 huangkai huangkai 1487 Jul 24 21:58 COPYINGdrwxrwxr-x. 6 huangkai huangkai 124 Jul 24 21:58 depsdrwxrwxr-x. 2 huangkai huangkai 6 Oct 20 15:36 conf-rw-rw-r--. 1 huangkai huangkai 11 Jul 24 21:58 INSTALL-rw-rw-r--. 1 huangkai huangkai 151 Jul 24 21:58 Makefile-rw-rw-r--. 1 huangkai huangkai 4223 Jul 24 21:58 MANIFESTO-rw-rw-r--. 1 huangkai huangkai 20530 Jul 24 21:58 README.md-rw-rw-r--. 1 huangkai huangkai 57764 Jul 24 21:58 redis.conf-rwxrwxr-x. 1 huangkai huangkai 271 Jul 24 21:58 runtest-rwxrwxr-x. 1 huangkai huangkai 280 Jul 24 21:58 runtest-cluster-rwxrwxr-x. 1 huangkai huangkai 281 Jul 24 21:58 runtest-sentinel-rw-rw-r--. 1 huangkai huangkai 7606 Jul 24 21:58 sentinel.confdrwxrwxr-x. 3 huangkai huangkai 4096 Jul 24 21:58 srcdrwxrwxr-x. 10 huangkai huangkai 167 Jul 24 21:58 testsdrwxrwxr-x. 8 huangkai huangkai 4096 Jul 24 21:58 utils[huangkai@sjq01 redis-4.0.1]$ 3、编译安装 编译: make 编译安装:sudo make install PREFIX=/usr/local/redis-4.0.1/ ，会在 /usr/local/redis-4.0.1/bin目录中创建Redis脚本文件12345678910111213141516171819202122232425262728293031[huangkai@sjq01 redis-4.0.1]$ make----------一系列编译与安装信息----------[huangkai@sjq01 redis-4.0.1]$ sudo make install PREFIX=/usr/local/redis-4.0.1/----日 志 信 息 开 始------cd src &amp;&amp; make installmake[1]: Entering directory `/usr/local/redis-4.0.1/src' CC Makefile.depmake[1]: Leaving directory `/usr/local/redis-4.0.1/src'make[1]: Entering directory `/usr/local/redis-4.0.1/src'Hint: It's a good idea to run 'make test' ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installmake[1]: Leaving directory `/usr/local/redis-4.0.1/src'----日 志 信 息 结 束------[huangkai@sjq01 redis-4.0.1]$ [huangkai@sjq01 bin]$ pwd/usr/local/redis-4.0.1/bin[huangkai@sjq01 bin]$ lltotal 21768-rwxr-xr-x. 1 root root 2450880 Oct 20 15:55 redis-benchmark-rwxr-xr-x. 1 root root 5740808 Oct 20 15:55 redis-check-aof-rwxr-xr-x. 1 root root 5740808 Oct 20 15:55 redis-check-rdb-rwxr-xr-x. 1 root root 2605168 Oct 20 15:55 redis-clilrwxrwxrwx. 1 root root 12 Oct 20 15:55 redis-sentinel -&gt; redis-server-rwxr-xr-x. 1 root root 5740808 Oct 20 15:55 redis-server[huangkai@sjq01 bin]$ 4、复制配置文件12345[huangkai@sjq01 redis-4.0.1]$ cp redis.conf ./conf/[huangkai@sjq01 redis-4.0.1]$ cd conf/[huangkai@sjq01 conf]$ lltotal 60-rw-rw-r--. 1 huangkai huangkai 57764 Oct 20 16:02 redis.conf 5、启动服务 编译完成后二进制文件是在src目录下，通过下面的命令启动Redis服务：123456789101112131415161718192021222324252627282930[huangkai@sjq01 redis-4.0.1]$ ./bin/redis-server ./conf/redis.conf5290:C 20 Oct 14:26:05.100 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo5290:C 20 Oct 14:26:05.100 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=5290, just started5290:C 20 Oct 14:26:05.100 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf5290:M 20 Oct 14:26:05.101 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.5290:M 20 Oct 14:26:05.101 # Server can't set maximum open files to 10032 because of OS error: Operation not permitted.5290:M 20 Oct 14:26:05.101 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'. _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 4.0.1 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 5290 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 5290:M 20 Oct 14:26:05.103 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.5290:M 20 Oct 14:26:05.103 # Server initialized5290:M 20 Oct 14:26:05.103 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.5290:M 20 Oct 14:26:05.103 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.5290:M 20 Oct 14:26:05.103 * Ready to accept connections 如果控制台出现如上信息，表示Redis已启动成功。 连接测试你可以使用内置的客户端命令redis-cli进行使用，新开一个连接窗口1234567[root@sjq01 ~]# cd /usr/local/redis-4.0.1/bin/[root@sjq01 bin]# ./redis-cli 127.0.0.1:6379&gt; SET name huangkaiOK127.0.0.1:6379&gt; GET name\"huangkai\"127.0.0.1:6379&gt; 关闭服务方式1、使用 kill 命令关闭进程(一般不建议此方式) 12345[root@sjq01 bin]# ps aux|grep redishuangkai 5290 0.3 0.7 145248 7968 pts/0 Sl+ 14:26 0:04 ./redis-server *:6379root 5370 0.0 0.0 112648 964 pts/1 R+ 14:50 0:00 grep --color=auto redis[root@sjq01 src]# kill -9 5290[root@sjq01 src]# &nbsp;&nbsp;方式2、优雅关闭Redis&nbsp;&nbsp;&nbsp;&nbsp;使用 SHUTDOWN 命令1234[root@sjq01 bin]# ./redis-cli 127.0.0.1:6379&gt; SHUTDOWNnot connected&gt; quit[root@sjq01 src]# WARNING FIX从上面redis启动之后的控制台打出的信息来看，有3条WARNING信息。他们分别如下： 1、WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 解决方式：12345678910第一种：无需重启系统即可生效；但重启以后信息丢失[huangkai@sjq01 redis-4.0.1]$ su - root #切换到root用户Password: Last login: Fri Oct 20 14:26:20 CST 2017 from 192.168.184.1 on pts/1[root@sjq01 ~]# echo 511 &gt;/proc/sys/net/core/somaxconn #修改配置----------第二种：即可生效，重启不会丢失[root@sjq01 ~]# vim /etc/sysctl.conf #打开配置文件，在其后追加net.core.somaxconn = 511[root@sjq01 ~]# sysctl -p #使配置文件sysctl.conf生效 原理：对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度,与如下两方面有关：一个是 somaxconn参数；另一个是使用该端口的程序中listen()函数.故而somaxconn会限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。 服务进程会自己限制侦听队列的大小，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。 redis配置文件中有个参数，tcp-backlog默认值是511，而系统默认的somaxconn是128，所以redis启动以后报出这个warnning 2、WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect. 解决办法：12345678910第一种：无需重启系统即可生效；但重启以后信息丢失[huangkai@sjq01 redis-4.0.1]$ su - root #切换到root用户Password: Last login: Fri Oct 20 14:26:20 CST 2017 from 192.168.184.1 on pts/1[root@sjq01 ~]# echo 1 &gt; /proc/sys/vm/overcommit_memory #修改配置----------第二种：即可生效，重启不会丢失[root@sjq01 ~]# vim /etc/sysctl.conf #打开配置文件，在其后追加vm.overcommit_memory=1[root@sjq01 ~]# sysctl -p #使配置文件sysctl.conf生效 原理： 内核参数overcommit_memory 确定了内存分配策略，可选值为[0、1、2]0： 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。1： 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。2： 表示内核允许分配超过所有物理内存和交换空间总和的内存 进程通常调用malloc()函数来请求分配内存，Linux支持超量分配内存，以允许分配比可用RAM加上交换内存的请求。Linux对大部分申请内存的请求都回复”yes”，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做Overcommit。当linux发现内存不足时，会发生OOM killer(OOM=out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。当oom-killer发生时，linux会选择杀死哪些进程？选择进程的函数是oom_badness函数(在mm/oom_kill.c中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟oom_score_adj有关，而且oom_score_adj可以被设置(-1000最低，1000最高)。 3、WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled. 意思是 你使用的是透明大页，可能导致redis延迟和内存使用问题解决办法：12345678910111213141516171819202122232425262728293031323334353637第一种方法：重启生效，不会丢失[huangkai@sjq01 redis-4.0.1]$ su - root #切换到root用户Password: Last login: Fri Oct 20 14:26:20 CST 2017 from 192.168.184.1 on pts/1[root@sjq01 ~]# vim /etc/rc.d/rc.local #打开配置文件，在其后追加if test -f /sys/kernel/mm/transparent_hugepage/enabled; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/enabledfiif test -f /sys/kernel/mm/transparent_hugepage/defrag; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/defragfi[root@sjq01 ~]# cat /etc/rc.d/rc.local #查看修改后的内容 #!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/localif test -f /sys/kernel/mm/transparent_hugepage/enabled; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/enabledfiif test -f /sys/kernel/mm/transparent_hugepage/defrag; thenecho never &gt; /sys/kernel/mm/transparent_hugepage/defragfi[root@sjq01 ~]# [root@sjq01 ~]# reboot #重启系统----------第二种方法：及时生效，重启丢失[root@sjq01 ~]# echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 原理： 正常来说，有两种方式来增加内存，可以管理的内存大小：1.增大硬件内存管理单元的大小。2.增大page的大小。第一个方法不是很现实，现代的硬件内存管理单元最多只支持数百到上千的page表记录，并且，对于数百万page表记录的维护算法必将与目前的数百条记录的维护算法大不相同才能保证性能，目前的解决办法是，如果一个程序所需内存page数量超过了内存管理单元的处理大小，操作系统会采用软件管理的内存管理单元，但这会使程序运行的速度变慢。 从redhat 6（centos，sl，ol）开始，操作系统开始支持 Huge Pages，也就是大页。简单来说， Huge Pages就是大小为2M到1GB的内存page，主要用于管理数千兆的内存，比如1GB的page对于1TB的内存来说是相对比较合适的。 THP（Transparent Huge Pages）是一个使管理Huge Pages自动化的抽象层。目前需要注意的是，由于实现方式问题，THP会造成内存锁影响性能，尤其是在程序不是专门为大内内存页开发的时候，简单介绍如下：操作系统后台有一个叫做khugepaged的进程，它会一直扫描所有进程占用的内存，在可能的情况下会把4kpage交换为Huge Pages，在这个过程中，对于操作的内存的各种分配活动都需要各种内存锁，直接影响程序的内存访问性能，并且，这个过程对于应用是透明的，在应用层面不可控制,对于专门为4k page优化的程序来说，可能会造成随机的性能下降现象。 将Redis命令加入环境变量123[rootoot@sjq01 bin]# vim + /etc/profile #打开配置文件，添加如下内容到最后export PATH=$PATH:/usr/local/redis-4.0.1/bin[root@sjq01 bin]# source /etc/profile #使配置文件生效","tags":[{"name":"Redis","slug":"Redis","permalink":"https://huankai.github.io/tags/Redis/"}]},{"title":"Nginx Linux 安装","date":"2018-02-22T07:15:02.742Z","path":"2018/02/22/Nginx_01/","text":"一、什么是 nginx?&nbsp;&nbsp;&nbsp;&nbsp;nginx是一种高性能的HTTP和反向代理服务器 ，同时也是一个代理邮件服务器，我们在nginx上可以发布网站，也可以实现负载均衡的功能 ，还可以作为邮件服务器实现收发邮件等功能 。所谓负载均衡是指当同时有多个用户访问服务器的时候，为了减轻服务器压力，我们需要将用户分别引入各服务器，分担服务器的压力。&nbsp;&nbsp;&nbsp;&nbsp;nginx 可以实现高并发、部署简单、 内存消耗少、成本低等优点。 二、nginx 安装 下载点击 此处 下载下载完后，将软件包上传到linux指定目录（也可以使用 wget下载，如下）： 123456[root@huangkai200 src]# wget http://nginx.org/download/nginx-1.10.3.tar.gz[root@huangkai200 src]# pwd/usr/src[root@huangkai200 src]# lltotal 910812-rw-r--r--. 1 root root 910812 Dec 24 21:45 nginx-1.10.3.tar.gz 添加用户 123[root@huangkai200 src]# useradd nginx -s /sbin/nologin -M -s 表示指定用户登陆所使用的 shell，nologin表示此用户不能登陆 -M 表示不创建用户home目录 安装 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安装过程中，可能会遇到一些错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nginx 安装需要 openssl、gcc、pcre 的支持&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可先执行如下命令：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install openssl openssl-devel -y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yum install pcre pcre-devel gcc-c++ -y 123456789[root@huangkai200 src]# tar -zxvf nginx-1.10.3.tar.gz # 解压文件[root@huangkai200 src]# ./configure --user=nginx --group=nginx --prefix=/usr/local/soft/nginx --with-http_stub_status_module --with-http_ssl_module--user 指定用户--group 指定组--prefix 指定安装路径--with-http_stub_status_model 激活状态信息--with-http_ssl_module 激活SSL功能 [root@huangkai200 src]# make[root@huangkai200 src]# makeinstall nginx 查看版本 &nbsp;&nbsp;&nbsp;&nbsp;进入nginx根目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${nginx}/sbin/nginx -v 三、启动、关闭、重启 nginxnginx 默认端口号为 80 ,在 Linux 中，默认 0 —— 1024 号端口需要 root用户才能启动，所以需要切换到 root用户，或者更改nginx 默认端口号。1234567[huangkai@huangkai200 sbin]$ su - root # 切换到root用户Password: Last login: Sat Mar 18 15:02:28 CST 2017 on pts/0[root@huangkai200 ~]# cd /usr/local/soft/nginx/[root@huangkai200 nginx]# ./sbin/nginx -t # 检查nginx 配置nginx: the configuration file /usr/local/soft/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/soft/nginx/conf/nginx.conf test is successful 启动nginx123456[root@huangkai200 nginx]# ./sbin/nginx [root@huangkai200 nginx]# ps -ef|grep nginxgdm 1338 1218 0 13:21 ? 00:00:00 /usr/libexec/ibus-engine-simpleroot 6597 1 0 15:20 ? 00:00:00 nginx: master process ./sbin/nginxnginx 6598 6597 0 15:20 ? 00:00:00 nginx: worker processroot 6610 6474 0 15:20 pts/0 00:00:00 grep --color=auto ngin 如上，表示 nginx 启动成功，确保防火墙打开或开放 80 端口的情况下，使用浏览器访问 http://ip地址 nginx 平滑启动进入 ${nginx}/sbin目录，执行 ./sbin nginx -s reload ，平滑启动必须是nginx已运行状态 nginx 停止进入 ${nginx}/sbin目录，执行 ./nginx stop","tags":[{"name":"Linux","slug":"Linux","permalink":"https://huankai.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://huankai.github.io/tags/Nginx/"}]},{"title":"Mac 常用快捷键","date":"2018-02-22T07:15:02.735Z","path":"2018/02/22/Mac快捷键/","text":"前往文件夹：在Finder 下按 command + shift + Ｇ 可以开启“前往文件夹”对话框，可以输入路径来快速访问Finder目录位置。 在打开或保存对话框窗口显示隐藏文件command+shift+句号 显示隐藏文件 在任何位置直接开启图片全屏幻灯片模式在Finder的任何位置，选中所有图片，然后按 command + option + Y ,就可以直接开启图片全屏幻灯片模式 快速进入聚焦模式，桌面只显示当前程序窗口command + option + H ,可以只保留当前程序窗口，将其他的隐藏 隐藏当前程序窗口有人来了不想给他看你在干什么，那么快用 command + H ,这时当前活跃的窗口会隐藏 直接锁定屏幕Control + Shift + Eject (开机键) ，可以直接锁定屏幕，进入屏幕保护模式，如果需要，还可以设置开启密码锁定，这样，需要密码才可以登陆了 直接关机 重启 睡眠关机：command + option + control +eject(开机键) 重启：command + control + eject 睡眠：command + option +eject Finder 快捷键command + z :撤销之前的操作，比如删除一个文件想找回来，这时不必去废纸篓找，按这个就好了。 command + 向上箭头 ：前往上层文件夹 光标在文本中的行首和行尾行首 ： command + 左方向键 行尾 ：command + 右方向键 强制退出当前响应的应用command + option + shift + esc 一到两秒，直到程序被强制退出 刷新command + r","tags":[{"name":"Mac","slug":"Mac","permalink":"https://huankai.github.io/tags/Mac/"}]},{"title":"Mac MySql安装","date":"2018-02-22T07:15:02.728Z","path":"2018/02/22/Mac安装Mysql/","text":"安装从官方 下载 mysql for mac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载后双击.dmg文件 , 先安装 mysql-5.5.23-osx10.6-x86.pkg （mysql主安装包）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再安装 MySQL.prefPane （将mysql安装在系统偏好设置中）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再安装 MySQLStartupItem.pkg （mysql自动启动包） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上三个都安装完后，mysql就安装完成。 mysql 环境变量配置：123打开终端，输入 cd ~ ,再输入open -e .base_profile 或者 nano .base_profile 在这个文件中加入 export PATH=$&#123;path&#125;:/usr/local/mysql/bin然后 control + c （保存）—&gt; Y（确认保存） —&gt; Enter （保存并退出） 修改mysql默认密码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完成后的默认root密码为空，这样很不安全，需要修改mysql密码方式一：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开终端，将mysql的密码设置为root ,在终端输入 mysqladmin -u root -p root ，会提示输入密码，由于默认密码为空，直接回车即可完成修改，到此mysql 安装完成。 方式二：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先用root登陆 mysql -u root -p ， 直接回车即可，执行以下命令：123use mysql;UPDATE user SET Password = PASSWORD(‘新密码&apos;) WHERE user = &apos;root&apos;;FLUSH PRIVILEGES; 修改mysql 编码mysql安装好后，需要保存数据， 默认mysql的编码为latin,在保存中文时就会有乱码问题，所以需要修改编码设置。先关闭Mysql服务 ，再执行以下命令：123456789101112进入mysql目录： cd /usr/local/mysql新建文件夹etc ： sudo mkdir etc复制文件my-default.cnf 到指目录并修改文件名为my.cnf： sudo cp /usr/local/mysql/support-files/my-default.cnf /usr/local/mysql/etc/my.cnf在my.cnf 中的[mysqld]部分加入 character-set-server=utf8在最后加入 [client] port=3306 default-character-set=utf8 注意：在mysql 5.7.18版本中，在 support-files 目录中没有 my-default.cnf文件，只需要创建 etc目录后，新建 my.cnf文件，写入如下即可123456789101112131415进入Mysql根目录 cd /usr/local/mysql(如果该目录下没有etc文件夹，则创建) mkdir etc #创建目录 cd etc #进入目录创建文件： vim my.cnf写入如下内容： [client] default-character-set=utf8 [mysqld] port=3306 character_set_server=utf8 basedir=/usr/local/mysql #mysql根目录 datadir=/usr/local/mysql/data #mysql data目录 mysql 删除mac 下的mysql 的dmg只有安装文件 ，没有卸载文件 ，只能手动输入命令来删除在删除操作之前，要停止Mysql的有关进程 ，打开终端，依次输入如下命令123456789sudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-)rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /var/db/receipts/com.mysql.* 到此，mysql删除完成","tags":[{"name":"Mac","slug":"Mac","permalink":"https://huankai.github.io/tags/Mac/"},{"name":"MySql","slug":"MySql","permalink":"https://huankai.github.io/tags/MySql/"}]},{"title":"Linux 常用命令","date":"2018-02-22T07:15:02.721Z","path":"2018/02/22/Linux常用命令/","text":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://huankai.github.io/tags/Linux/"}]},{"title":"JPQL语法","date":"2018-02-22T07:15:02.715Z","path":"2018/02/22/JPQL/","text":"JPQL（Java Persistence Query Language，Java 持久化查询语言）和 SQL 之间有很多相似之处，它们之间主要的区别在于前者处理 JPA 实体类，而后者则直接涉及关系数据。在 JPQL 中，可以使用SELECT、UPDATE和DELETE语法来定义查询。 1. 查询语法：SELECT ... FROM ... [WHERE ...] [GROUP BY ... [HAVING ...]] [ORDER BY ...] FROM 子句通过声明一个或多个标识符变量来定义查询的范围 WHERE 子句 用于限制查询到的对象或值的条件表达式 GROUP BY 子句根据一组属性对查询结果进行分组 HAVING 子句配合GROUP BY子句使用，以根据条件表达式进一步限制查询结果 ORDER BY 子句对查询结果进行排序 1234567891011121314151617//部门@Entity(name = \"department\")public class Department &#123; @Id @GeneratedValue private Long id; private String name; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"department_id\") private Set&lt;Employee&gt; employees; // getters and setters &#125; 123456789101112131415161718192021222324252627//员工@Entity(name = \"employee\")public class Employee &#123; @Id @GeneratedValue private Long id; private String name; @Enumerated(EnumType.STRING) private Sex sex; private Integer age; private Boolean married; private Double salary; private Date hireDate; @ManyToOne(fetch = FetchType.LAZY) private Department department; // getters and setters &#125; 1234567891011121314151617181920public enum Sex &#123; MALE(\"男\"), FEMALE(\"女\"), ; private final String displayText; private Sex(String displayText) &#123; this.displayText = displayText; &#125; @Override public String toString() &#123; return displayText; &#125; &#125; 1.1 基础查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量示例：查询所有的雇员信息12@Query(\"SELECT E FROM Employee E\")List&lt;Employee&gt; selectAll(); 1.2 查询参数JPQL 支持两种查询参数，它们分别是命名参数和位置参数 1.2.1 命名参数语法：:自定义的参数名称示例：按性别和薪资范围查找雇员信息12@Query(\"SELECT E FROM Employee E WHERE E.sex = :sex AND E.salary &gt; :salary\")List&lt;Employee&gt; selectByNamedParams(@Param(\"sex\") Sex sex, @Param(\"salary\") Double salary); 在方法的参数列表中，需要使用@Param注解标注每个参数的名称，使之与查询语句参数名称匹配 1.2.2 位置参数语法：?位置编号的数值示例：按姓名和性别查找雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.sex = ?1 AND E.salary &gt; ?2\")List&lt;Employee&gt; selectByPositionalParams(Sex sex, Double salary); 在方法的参数列表中，参数的顺序需要与查询语句中参数标注的编号依次对应起来。 1.3 关联查询通过使用关键字[LEFT|INNER] JOIN联接关系属性查询 1.3.1 单值关联查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.单值关联字段 [AS] 标识符变量2 ... 示例：按部门名称查找该部门所有的雇员信息12@Query(\"SELECT E FROM Employee E JOIN E.department D WHERE D.name = ?1\")List&lt;Employee&gt; selectByDeptName(String deptName); 1.3.2 多值关联查询语法1：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.多值关联字段 [AS] 标识符变量2 ...示例：查询薪资大于10000的所有雇员所属的部门信息12@Query(\"SELECT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedField(); 语法2：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量, IN(实体名称.多值关联字段) [AS] 标识符变量2 ...12@Query(\"SELECT D FROM Department D, IN(D.employees) E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedCollection(); 1.4 去重查询语法：SELECT DISTINCT 标识符变量 FROM 实体名称 [AS] 标识符变量 ...示例：查询薪资大于10000的所有雇员所属的部门信息，并消除查询结果中的重复的部门 12@Query(\"SELECT DISTINCT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedFieldDistinct(); 1.5 字面值JPQL 支持的字面值有以下的4种，它们分别是：字符串、数字、布尔、枚举。 1.5.1 字符串语法：&#39;字符串&#39;示例：查询给定名字的雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.name = '张三'\")Employee selectByLiteralString(); 如果字符串中含有单引号，则用两个单引号来表示。如：Li’Si -&gt; Li’’Si 12@Query(\"SELECT E FROM Employee E WHERE E.name = 'Li''Si'\")Employee selectByLiteralStringWithQuote(); 1.5.2 数字整数类型：如24、+24、-24、24L，支持 Java Long 范围的数值。浮点类型：如24.、24.6、+24.6、-24.6、24.6F、24.6D，支持 Java Double 范围的数值。示例：查询薪资大于10000的所有雇员12@Query(\"SELECT E FROM Employee E WHERE E.salary &gt; 10000.0\")List&lt;Employee&gt; selectByLiteralNumber(); 1.5.3 布尔布尔类型的可选值为：TRUE或FALSE，它们不区分大小写。示例：查找已婚的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.married = TRUE\")List&lt;Employee&gt; selectByLiteralBool(); 1.5.4 枚举枚举类名必须指定为完全限定类名。示例：查询所有女性的雇员12@Query(\"SELECT E FROM Employee E WHERE E.sex = org.fanlychie.enums.Sex.FEMALE\")List&lt;Employee&gt; selectByLiteralEnum(); 1.6 模糊查询 表达式 匹配 不匹配 E.name LIKE ‘张%’ 张三 小张伟 E.name LIKE ‘张_’ 张三 张三丰 E.name LIKE ‘张_% 张_三 张三 示例：查询张性的所有雇员12@Query(\"SELECT E FROM Employee E WHERE E.name LIKE '张%'\")List&lt;Employee&gt; selectByLikeLiteralString(); 1.7 空集合查询通过使用关键字IS [NOT] EMPTY来查找关联的属性集合的值为空的记录。示例：查找尚无雇员的所有部门12@Query(\"SELECT D FROM Department D WHERE D.employees IS EMPTY\")List&lt;Department&gt; selectByEmpty(); 1.8 构造器查询结果的类型如果不是持久化的实体类，必须使用该类的完全限定名。语法：SELECT NEW 类的完全限定名(参数1, 参数2, …) …示例：查询所有的雇员信息12@Query(\"SELECT NEW com.hk.model.SimpleEmployee(E.name, E.sex) FROM Employee E\")List&lt;SimpleEmployee&gt; selectSimpleEmployees(); 12345678910111213141516package com.hk.model; public class SimpleEmployee &#123; private String name; private Sex sex; public SimpleEmployee(String name, Sex sex) &#123; this.name = name; this.sex = sex; &#125; // getters and setters &#125; 2. 更新示例：更新某个雇员的婚姻状态和薪资信息 1234@Modifying@Transactional@Query(\"UPDATE Employee SET married = ?2, salary = ?3 WHERE id = ?1\")int update(Long id, Boolean married, Double salary); @Query无法进行 DML（Data Manipulation Language 数据操控语言，主要语句有 INSERT、DELETE、UPDATE）操作，如需更新数据库表的数据需要标注@Modifying注解，并且需要使用支持事务的@Transactional注解。 3. 删除示例：删除没有雇员的部门信息 1234@Modifying@Transactional@Query(\"DELETE FROM Department D WHERE D.employees IS EMPTY\")int delete(); 参考文档文献链接：https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm 、https://docs.oracle.com/html/E13946_04/ejb3_langref.html","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA 一对多与多对一","date":"2018-02-22T07:15:02.708Z","path":"2018/02/22/JPA_一对多、多对一/","text":"1、OneToMany@OneToMany 是属性或方法级别的注解，用于定义源实体与目标实体是一对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数） cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载） orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false 1.1、 一对多外键关联1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：12345678910111213141516171819202122232425CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user_addresses` ( `user_id` bigint(20) NOT NULL, `addresses_id` bigint(20) NOT NULL, PRIMARY KEY (`user_id`,`addresses_id`), UNIQUE KEY `UK_i5lp1fvgfvsplfqwu4ovwpnxs` (`addresses_id`), CONSTRAINT `FKfm6x520mag23hvgr1oshaut8b` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`), CONSTRAINT `FKth1icmttmhhorb9wiarm73i06` FOREIGN KEY (`addresses_id`) REFERENCES `address` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; Hibernate @OneToMany 默认会产生一张中间表，如上例的 user_addresses 表。为了避免这种情况，你可以在一的一方使用 @JoinColumn 注解： 123@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)@JoinColumn(name = \"user_id\")private Set&lt;Address&gt; addresses; 产生的 DDL 语句（MySQL）：12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这样一来，多的一方通过外键直接与一的一方发生关联，不需要中间表。 2、@ManyToOne@ManyToOne 是属性或方法级别的注解，用于定义源实体与目标实体是多对一的关系，属性参数见 @OneToMany 。 2.1、 多对一外键关联123456789101112131415@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3、 @OneToMany &amp; @ManyToOne一对多 &amp; 多对一双向外键关联示例： 123456789101112131415161718@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"user_id\") private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA 多对多","date":"2018-02-22T07:15:02.700Z","path":"2018/02/22/JPA_多对多/","text":"@ManyToMany 是属性或方法级别的注解，用于定义源实体与目标实体是多对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数） cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载） 1. 多对多单向外键关联123456789101112Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; // getters and setters &#125; 1234567891011121314@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_courses` ( `student_no` varchar(255) NOT NULL, `courses_id` bigint(20) NOT NULL, PRIMARY KEY (`student_no`,`courses_id`), KEY `FKlwviiijdg10oc2ui4yl7adh1o` (`courses_id`), CONSTRAINT `FKa6x7sxxnd9c1pat349a01bsow` FOREIGN KEY (`student_no`) REFERENCES `student` (`no`), CONSTRAINT `FKlwviiijdg10oc2ui4yl7adh1o` FOREIGN KEY (`courses_id`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. @JoinTable与 @Table 注解相类似，不同的是，@JoinTable 注解是用于定义关联表，它只能标注在实体类型的成员属性或方法上，常用于多对多或多对一的关联映射。如果没有声明，则使用该注解的默认值。 参数 类型 描述 name String 连接表的名称 catalog String 默认为数据库系统缺省的 catalog schema String 默认为用户缺省的 schema joinColumns JoinColumn[] 连接表中的外键列，通过使用 @JoinColumn 注解来声明，该外键参照源实体的主键 inverseJoinColumns JoinColumn[] 与 joinColumns 参数作用类似，只不过该外键参照的是目标实体的主键 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件 indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引 foreignKey ForeignKey 用于生成表时定义 joinColumns 参数的外键约束 inverseForeignKey ForeignKey 用于生成表时定义 inverseJoinColumns 参数的外键约束 Course 定义不变，Student 定义改为：1234567891011121314151617@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = \"student_course\", joinColumns = @JoinColumn(name = \"sno\"), inverseJoinColumns = @JoinColumn(name = \"cid\")) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）：1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_course` ( `sno` varchar(255) NOT NULL, `cid` bigint(20) NOT NULL, PRIMARY KEY (`sno`,`cid`), KEY `FKkx4bkddvbfs0ese9v7hc5rycg` (`cid`), CONSTRAINT `FKrfibef5g98fllv2tlxuiii0lu` FOREIGN KEY (`sno`) REFERENCES `student` (`no`), CONSTRAINT `FKkx4bkddvbfs0ese9v7hc5rycg` FOREIGN KEY (`cid`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. 多对多双向外键关联类 Student 定义不变，Course 类的定义改为： 123456789101112131415@Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; @ManyToMany(mappedBy = \"courses\") private Set&lt;Student&gt; students; // getters and setters &#125; 产生的 DDL 语句与多对多单向外键关联产生的一致。","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Transient  注解","date":"2018-02-22T07:15:02.692Z","path":"2018/02/22/JPA_Transient/","text":"@Transient 是属性或方法级别的注解，该注解没有参数，用于标注属性是瞬态而非持久的。 示例:123456789101112131415@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @Transient private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：12345CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Temporal   注解","date":"2018-02-22T07:15:02.685Z","path":"2018/02/22/JPA_Temporal/","text":"@Temporal 是属性或方法级别的注解，用于声明属性持久化到数据库时所使用的时间精度。该注解可以应用于任何以下类型的实体类属性： java.util.Date java.util.Calendar 参数 类型 描述 value TemporalType 存储的类型，可选值：TemporalType.DATE（日期）TemporalType.TIME（时间）TemporalType.TIMESTAMP（日期和时间） 示例：12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; @Temporal(TemporalType.DATE) private Date birthday; @Temporal(TemporalType.TIMESTAMP) private Date lastLoginTime; @Temporal(TemporalType.TIME) private Date tokenExpiredTime; // getters and setters &#125; 产生的 DDL 语句（MySQL）：1234567CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `birthday` date DEFAULT NULL, `last_login_time` datetime DEFAULT NULL, `token_expired_time` time DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据值样例：12345+----+------------+---------------------+--------------------+| id | birthday | last_login_time | token_expired_time |+----+------------+---------------------+--------------------+| 1 | 2017-05-14 | 2017-05-14 15:12:49 | 15:12:49 |+----+------------+---------------------+--------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Table 注解","date":"2018-02-22T07:15:02.675Z","path":"2018/02/22/JPA_Table/","text":"@Table 是类级别的注解，用于声明实体映射到数据库中的具体的表。 参数 类型 描述 name String 表的名称，默认为实体名称（参考 @Entity 注解的 name 参数说明），因此如果实体名称与映射的表名称一致时，@Table 注解常常可以省略 catalog String 默认为数据库系统缺省的 catalog schema String 默认为用户缺省的 schema indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件 1、catalog 和 schema 的区别catalog 和 schema 主要用来解决数据库系统命名冲突的问题。一个数据库系统可以包含多个 catalog，每个 catalog 可以包含多个 schema，而每个 schema 又可以包含多个数据库对象（表、视图等）。不同的数据库系统对 catalog 和 schema 的支持方式有所不同，常见的数据库系统： 数据库系统 catalog schema MySQL 不支持 数据库名 Oracle 不支持 用户 ID SQLServer 数据库名 对象属主名 DB2 指定数据库对象时，Catalog 可以省略 Catalog 属主名 Sybase 数据库名 数据库属主名 2、 唯一约束和索引的区别唯一约束是用来确保数据的正确性，它不允许表中存在重复的数据，若新插入的数据在表中已经存在，则更新操作失败。在数据库系统中，创建一个唯一约束的同时，也会为该约束所指定的所有列创建一个唯一索引，即约束包含索引。 索引是用来优化数据库表数据的检索性能的。通常，出现在查询 SQL 的 WHERE 子句和 JOIN 子句中的列可以考虑为其建立索引。 3、 @UniqueConstraint用于声明表的唯一约束，这些仅在允许自动更新数据库表结构的场景中起到作用。 参数 类型 描述 name String 约束名称，如果不指定，默认使用数据库提供商所生成的值 columnNames String[] 约束的列名称 4、 @Index用于声明表的索引，这些仅在允许自动更新数据库表结构的场景中起到作用。另外，不需要为表的主键指定索引，因为主键索引会自动被创建。 参数 类型 描述 name String 索引名称，如果不指定，默认使用数据库提供商所生成的值 columnList String 要包含在索引中的列名称 unique boolean 索引是否唯一，默认为 false 5、@Table5.1 唯一约束name 列、mail 列的值必须是唯一的，不允许出现重复的值：123456789101112131415161718@Entity(name = \"user\")@Table(uniqueConstraints = &#123; @UniqueConstraint(name = \"unique_name\", columnNames = \"name\"), @UniqueConstraint(name = \"unique_mail\", columnNames = \"mail\")&#125;)public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：12345678CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name` (`name`), UNIQUE KEY `unique_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.2。 联合唯一约束多列联合唯一约束，name 列和 mail 列不能同时出现相同的值： 123456789101112131415@Entity(name = \"user\")@Table(uniqueConstraints = @UniqueConstraint(name = \"unique_name_mail\", columnNames = &#123;\"name\", \"mail\"&#125;))public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：1234567CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.3、 单列索引为 name 列和 mail 列分别建立索引 123456789101112131415161718@Entity(name = \"user\")@Table(indexes = &#123; @Index(name = \"index_name\", columnList = \"name\"), @Index(name = \"index_mail\", columnList = \"mail\")&#125;)public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：12345678CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name` (`name`), KEY `index_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.4、 多列索引为 name 列和 mail 列建立多列索引： 123456789101112131415@Entity(name = \"user\")@Table(indexes = @Index(name = \"index_name_mail\", columnList = \"name,mail\"))public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.5、 单列索引和多列索引的区别当 SQL 查询条件中包含 name 和 mail 时： 1SELECT * FROM user WHERE name = 'admin' AND mail = 'admin@163.com' 如果为 name 和 mail 列分别建立索引，当执行查询时，MySQL 只能使用一个索引。如果发现有多个单列索引可用，MySQL 会试图选择一个限制最严格的索引来检索，而其他索引则利用不上。使用分析器分析查询 SQL： 1EXPLAIN SELECT * FROM user WHERE name = 'admin' AND mail = 'admin@163.com' 结果如下： 12345+--------+------+-----------------------+------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+| 1 | SIMPLE | user | ref | index_name,index_mail | index_mail | 768 | const | 1 | Using where |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+ MySQL 优化器如果发现可以使用多个索引查找后的交集/并集定位数据，那么 MySQL 优化器就会尝试使用 index merge（索引合并）的方式来查询： 1EXPLAIN SELECT * FROM user WHERE name = 'admin' AND mail = 'admin@163.com' 结果如下：12345+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| 1 | SIMPLE | user | index_merge | index_name,index_mail | index_name,index_mail | 768,768 | NULL | 1 | Using intersect(index_name,index_mail); Using where; Using index |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+ 对于多列索引，由于索引文件以B树的数据结构存储，MySQL 能够快速转到合适的 name，然后再转到合适的 mail。在建立多列索引时，应该将严格的索引放在前面，这样筛选数据的时候力度会更大，效率更高。 使用分析器分析查询 SQL：1EXPLAIN SELECT * FROM user WHERE name = 'admin' AND mail = 'admin@163.com' 结果如下： 12345+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| 1 | SIMPLE | user | ref | index_name_mail | index_name_mail | 1536 | const,const | 2 | Using where; Using index |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @OneToOne   注解","date":"2018-02-22T07:15:02.667Z","path":"2018/02/22/JPA_OneToOne/","text":"@OneToOne 是属性或方法级别的注解，用于定义源实体与目标实体是一对一的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的类型，因此该参数通常可以缺省 mappedBy String 用在双向关联中。如果关系是双向的，只能有一方作为主体端，另一方则需声明此参数以表明将表间的这种关联关系转交给对方来维护 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据 optional boolean 源实体关联的目标实体是否允许为 null，默认为 true orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false 注：目标实体是指被关系注解（如：@OneToOne）标注的属性或方法所对应的类，源实体是指该属性或方法所属的类。 1. 一对一单向外键关联123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) private IdCard idCard; // getters and setters &#125; 123456789101112@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `id_card_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKar03p8ob32rgj1axxy2q507v5` (`id_card_no`), CONSTRAINT `FKar03p8ob32rgj1axxy2q507v5` FOREIGN KEY (`id_card_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `idcard` ( `no` varchar(255) NOT NULL, `expiry_date` date DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. orphanRemoval 与 CascadeType.REMOVE 的区别CascadeType.REMOVE（或包含 CascadeType.REMOVE 的 CascadeType.ALL）表示级联删除，只有对源实例做删除操作时，才会级联删除关联的目标实例。如上例，删除 id=1 的 Person 实例，那么，该实例所关联的 IdCard 实例也将被删除。示例代码片段： 1personRepository.delete(1L); 假设 person.idCard = idCard1，如果 person.idCard 属性被赋予了另外一个 IdCard 实例：person.idCard = idCard2 或被设为 null：person.idCard = null。此时，身份证 idCard1 已经找不到任何一个人和它发生关联，这样的值我们成为孤值，它已经失去了存在的意义。如果程序中设置了 orphanRemoval = true，那么，当更新 person 实例时，idCard1 实例将会被自动删除。示例代码片段： 123Person person = personRepository.findOne(1L);person.setIdCard(null);personRepository.save(person); 3. 一对一双向外键关联类 Person 定义不变，IdCard 类的定义改为： 123456789101112131415@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; @OneToOne(mappedBy = \"idCard\") private Person person; // getters and setters &#125; 产生的 DDL 语句与一对一单向外键关联产生的一致。 4. @JoinColumn 参数 类型 描述 name String 外键列的名称，默认为：属性的名称 + _ + 属性对应的实体的主键列的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写）。 unique boolean 外键列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式，实质上是在声明唯一约束。默认值为 false nullable boolean 外键列的值是否允许为 null。默认为 true insertable boolean 外键列是否包含在 INSERT 语句中，默认为 true updatable boolean 外键列是否包含在 UPDATE 语句中，默认为 true columnDefinition String 生成外键列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列 table String 外键列所属的表的名称。默认值：如果是外键 @OneToOne 或 @ManyToOne 关联，则为源实体的表的名称；如果是单向外键 @OneToMany 关系，则为目标实体的表的名称；如果是 @ManyToMany、@OneToOne、双向 @ManyToOne、双向 @OneToMany 关联，则为连接表的名称 若修改 Person 类的定义为：12345678910111213141516@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = \"idcard_no\") private IdCard idCard; // getters and setters &#125; 产生的 DDL 语句（MySQL）：12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `idcard_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FK56rk440ff4uyhc5vdis0jeiut` (`idcard_no`), CONSTRAINT `FK56rk440ff4uyhc5vdis0jeiut` FOREIGN KEY (`idcard_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @MappedSuperclass  注解","date":"2018-02-22T07:15:02.658Z","path":"2018/02/22/JPA_MappedSuperclass/","text":"@MappedSuperclass 是类级别注解，该注解没有任何参数，被该注解标注的类不会映射到数据库中单独的表，但该类所拥有的属性都将映射到其子类的数据库表的列中。 1、 示例12345678910111213@MappedSuperclasspublic class BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) protected Long id; @Column(name = \"create_time\") protected Date createTime; // getters and setters &#125; 12345678910@Entity(name = \"student\")public class Student extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：1234567CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_time` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、 @AttributeOverride对于被 @MappedSuperclass 注解标注的类派生出来的子类，可以使用 @AttributeOverride 注解重新定义以覆盖父类中的映射信息。 参数 类型 描述 name String 属性名称 column Column 列信息 1234567891011@Entity(name = \"student\")@AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))public class Student extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：1234567CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3、 @AttributeOverrides如果需要重新定义父类中的多个映射信息，需要使用 @AttributeOverrides 注解。 参数 类型 描述 value AttributeOverride[] @AttributeOverride 注解列表 1234567891011121314@Entity(name = \"student\")@AttributeOverrides(&#123; @AttributeOverride(name = \"id\", column = @Column(name = \"student_id\")), @AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))&#125;)public class Student extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `student` ( `student_id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`person_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Id   注解","date":"2018-02-22T07:15:02.650Z","path":"2018/02/22/JPA_Id/","text":"@Id 是属性或方法级别的注解，该注解没有参数，用于标注实体的主键（映射到数据库表的主键）。 示例：12345678910111213@Entity(name = \"student\")public class Student implements Serializable &#123; @Id private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `student` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @GeneratedValue  注解","date":"2018-02-22T07:15:02.642Z","path":"2018/02/22/JPA_GeneratedValue/","text":"@GeneratedValue 是属性或方法级别的注解，它结合 @Id 注解为主键的值提供生成策略的规范。 参数 类型 描述 strategy GenerationType 主键生成策略。可选值：GenerationType.TABLEGenerationType.SEQUENCEGenerationType.IDENTITYGenerationType.AUTO 默认是 GenerationType.AUTO generator String 主键生成器的名称。该名称为 @TableGenerator 或 @SequenceGenerator 注解中 name 参数的值。默认为持久化提供者（如 Hibernate）提供的id生成器 1、 @GeneratedValue1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.1、 GenerationType.TABLE该策略使用一个特殊的数据库表来为各个实体分配主键，并确保主键值的唯一性。它不依赖环境和数据库系统的具体实现，在不同数据库之间可以很容易的进行移植。 1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE) private Long id; private String name; private String mail; // getters and setters &#125; 在 Hibernate + MySQL 环境产生的 DDL 语句： 123456789101112CREATE TABLE `student` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `hibernate_sequences` ( `sequence_name` varchar(255) NOT NULL, `sequence_next_hi_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`sequence_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 其中，hibernate_sequences 表就是用来为各个实体分配主键的，sequence_name 用于存储各个实体名称，sequence_next_hi_value 则是用于存储各个实体的下一个主键的值。 每次保存 Student 实体对象的数据的时候，首先会到 hibernate_sequences 表中查询该实体名称是否已经存在，若不存在，则向 hibernate_sequences 表插入一行该实体名称的记录，若已经存在，则直接取出 sequence_next_hi_value 的值作为本次 Student 数据的主键值，接着更新 hibernate_sequences 表的记录，使该实体名称的记录的 sequence_next_hi_value 值加1。最后保存 Student 实体对象的记录。 1.1.1、 @TableGenerator表生成器，GenerationType.TABLE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器 table String 生成器表的名称。默认为持久化提供者（如 Hibernate）提供的名称 catalog String 生成器表的 catalog，默认为数据库系统缺省的 catalog schema String 生成器表的 schema，默认为用户缺省的 schema pkColumnName String 生成器表的主键列的名称，默认为持久化提供者（如 Hibernate）提供的名称 valueColumnName String 生成器表存储生成的值的列的名称，默认为持久化提供者（如 Hibernate）提供的名称 pkColumnValue String 生成器表中的主键值，用于将不同的实体区分开来。默认为实体名称（@Entity 注解的 name 参数的值） initialValue int 用于初始化生成器生成的初始值。默认值是0。在 Hibernate 环境中，需要开启 hibernate.id.new_generator_mappings=true（Spring JPA 配置为：spring.jpa.hibernate.use-new-id-generator-mappings=true），否则此参数无效。并且如果实体记录已经存在生成器表中，此参数也无效（即只有当实体记录第一次写入生成器表中时此参数生效） allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50 uniqueConstraints UniqueConstraint[] 表的唯一约束 indexes Index[] 表的索引 123456789101112131415161718192021@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 产生的 DDL 语句（MySQL）：123456789101112131415161718CREATE TABLE `student` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `pk_sequences` ( `entity_name` varchar(255) NOT NULL, `sequence_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`entity_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.2、 GenerationType.SEQUENCE某些数据库系统（如：Oracle、DB2、PostgreSQL 等）底层支持使用序列对象来为表的主键提供唯一值，而对于不支持序列对象的数据库（如：MySQL、SQLServer），则不应使用此策略。 1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617181920212223242526@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 这种方式是多个实体共用同一个序列对象，这将导致各个实体分配到的序列值不连续，并且消耗加快 1.2.1、 @SequenceGenerator序列生成器，GenerationType.SEQUENCE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器 sequenceName String 序列对象的名称，默认为持久化提供者（如 Hibernate）提供的名称 catalog String 序列生成器的 catalog schema String 序列生成器的 schema initialValue int 用于初始化序列对象生成的初始值。默认值是1 allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50 12345678910111213141516171819@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"personSeqGenerator\") @SequenceGenerator( name = \"personSeqGenerator\", sequenceName = \"PERSON_SEQ\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"userSeqGenerator\") @SequenceGenerator( name = \"userSeqGenerator\", sequenceName = \"USER_SEQ\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 1.3、 GenerationType.IDENTITY大部分数据库系统（如：MySQL、SQLServer、DB2、Sybase、HypersonicSQL 等）底层支持表的主键自增长，而对于不支持主键自增长的数据库（如：Oracle），则不能使用此策略。 1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）：123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.4、 GenerationType.AUTO自动为特定的数据库选择适当的策略，这是比较常用的策略。 1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 由于 @GeneratedValue 注解默认采用的策略就是 GenerationType.AUTO，因此可以简写成：1234567891011121314@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Entity 注解","date":"2018-02-22T07:15:02.633Z","path":"2018/02/22/JPA_Entity/","text":"@Entity 是类级别注解，用于声明标注的类是持久的，我们把这样的类称为实体类。每个实体类映射到数据库中的一张表，实体类所拥有的属性将映射成数据库表的列。并由 JPA 负责将对实体的操作转换为对数据库表的操作。 参数 类型 描述 name String 实体名称，在 JPQL 中用于引用该实体类。默认为该类的简单类名称 示例 123456@Entity(name = \"person\")public class Person implements Serializable &#123; ... ... &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Column   注解","date":"2018-02-22T07:15:02.625Z","path":"2018/02/22/JPA_Column/","text":"@Column 是属性或方法级别的注解，用于指定持久化属性映射到数据库表的列。如果没有指定列注释，则使用其默认值。 参数 类型 描述 name String 列的名称，默认为属性的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写） unique boolean 列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式， 实质上是在声明唯一约束。默认值为 false nullable boolean 列的值是否允许为 null。默认为 true insertable boolean 列是否包含在 INSERT 语句中，默认为 true updatable boolean 列是否包含在 UPDATE 语句中，默认为 true columnDefinition String 生成列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列 table String 当前列所属的表的名称 length int 列的长度，仅对字符串类型的列生效。默认为255 precision int 列的精度，仅对十进制数值有效，表示有效数值的总位数。默认为0 scale int 列的精度，仅对十进制数值有效，表示小数位的总位数。默认为0 1、 示例12345678910111213141516171819202122232425@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; @Column(nullable = false, length = 32) private String name; @Column(length = 128) private String mail; @Column(columnDefinition = \"char(11) NOT NULL\") private String phone; @Column(precision = 5, scale = 2) private BigDecimal salary; @Column(precision = 5, scale = 2) private double assets; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456789CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double NOT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 可以看出，salary 字段的精度控制生效了，但对于 double 类型的 assets 字段的精度控制没有生效，为了使其生效，将代码修改为：12@Column(columnDefinition = \"double(5, 2)\")private double assets; 产生的 DDL 语句（MySQL）：123456789CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double(5,2) DEFAULT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"JPA @Basic   注解","date":"2018-02-22T07:15:02.609Z","path":"2018/02/22/JPA_Basic/","text":"@Basic 是属性或方法级别的注解，该注解可以应用于任何以下类型的实体类属性： Java 原始类型 原始类型的包装类型 String java.math.BigInteger java.math.BigDecimal java.util.Date java.util.Calendar java.sql.Date java.sql.Time java.sql.Timestamp byte[] Byte[] char[] Character[] 枚举 任意实现 java.io.Serializable 接口的类型 在实体类中，对以上这些类型的属性，如果没有标注 @Basic 注解，则将使用 @Basic 注解的默认值 参数 类型 描述 fetch FetchType 属性值的加载策略。可选值：FetchType.EAGER：即时加载；FetchType.LAZY：延迟加载，当第一次访问属性时才进行数据的加载；默认为 FetchType.EAGER。 optional boolean 是否允许为 null，默认为 true 示例：123456789101112131415@Entity(name = \"student\")public class Student implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @Basic(optional = false, fetch = FetchType.LAZY) private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"https://huankai.github.io/tags/JPA/"}]},{"title":"Idea 使用","date":"2018-02-22T07:15:02.587Z","path":"2018/02/22/Idea_01/","text":"下载官网下载：点击 官网 下载 如下，有windows版本 、maxOS版本、Linux版本，windows版本又分为安装版与 zip版本，可以下载zip版后直接解压到本地磁盘某个目录即可。 安装zip版本的只需要解压，没有安装过程。exe版本的根据个性化设置走完安装向导即可。 配置1、全局编码配置:1.1、先进入idea安装目录 的bin目录，目录文件如下：Idea.exe与 idea.exe.vmoptions为 32位系统启动程序与启动配置文件信息idea64.ext与idea64.exe.vmoptions为 64位系统启动程序 与配置文件信息，根据操作系统的位数修改对应的配置文件，在配置文件新一行加入-Dfile.encoding=UTF-8 1.2、启动idea，进入设置界面，配置如下： 上面要将Transparent native-to-ascii conversion选项勾选,否则项目中properties文件中的中文会显示成Unicode编码值。 2、项目配置 2.1、添加SDK：如下，选择你本地安装的JAVA_HOME目录即可 Project SDK 配置:如上：1处是指定 SDK，如果没有，可以new 一个2 处是指定项目指定的语言等级，jdk1.8 可指定 8，如下 2.2、忽略大小写提示：Idea默认的提示是区分大小写的，对于使用过eclipse的来说很不友好，设置如下：将First letter改为 None即可。 2.3、方法体不自动折叠：默认情况下，打开java文件后方法体内容是折叠成一行了，如下图所示： 设置如下：File -&gt;settings -&gt; Editor -&gt; Code Folding ,将 One-line-methods 去掉勾选。 2.4、取消显示形参名：默认情况下，idea调用的方法会有形参名显示，如下 设置如下：File -&gt;settings -&gt; Editor -&gt; Appearance ,将 show parameter name hints 去掉勾选 2.5、警告配置：Idea 有很多黄色的警告信息，并与 eclipse的警告信息甚至有些相反，eclipse有的idea没有，看起来很不习惯。 如下所有警告设置都在 File -&gt; setting -&gt; Editor -&gt; Inspections Access can be private 出现此种警告，表示定义的方法(包含public)没有被外部调用才出现的警告，设置如下：去掉所选择的复选框 方法注释没有定义描述出现此种警告，表示方法有文档注释的标签，却没有描述，如下，@return 没有描述设置如下： 去掉勾选框 泛型右边也指定具体类型 相同代码下滑线提示Idea会检查项目中是否有相同的代码，如果有，会以下划线提示，如果不需要提示，配置如下： 关闭Typo检查 默认注解参数值警告当在类、属性或方法上使用注解时，如果注解的某些属性有默认值，而此时你标注的注解属性也是默认值，idea也发会出警告，如果想取消警告，配置如下： 类未被使用警告将创建一个类后，如果这个类一直未被使用，会有警告，如果想取消警告，配置如下： 参考文档：https://www.jetbrains.com/idea/documentation/http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/ 快捷键：http://blog.csdn.net/djcken/article/details/16362629","tags":[{"name":"Idea","slug":"Idea","permalink":"https://huankai.github.io/tags/Idea/"}]}]